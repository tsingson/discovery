// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: discovery.proto

package eureka

import (
	bytes "bytes"
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type RespMsg struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Msg                  string   `protobuf:"bytes,2,opt,name=Msg,proto3" json:"Msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RespMsg) Reset()         { *m = RespMsg{} }
func (m *RespMsg) String() string { return proto.CompactTextString(m) }
func (*RespMsg) ProtoMessage()    {}
func (*RespMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e7ff60feb39c8d0, []int{0}
}
func (m *RespMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RespMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RespMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RespMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RespMsg.Merge(m, src)
}
func (m *RespMsg) XXX_Size() int {
	return m.Size()
}
func (m *RespMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_RespMsg.DiscardUnknown(m)
}

var xxx_messageInfo_RespMsg proto.InternalMessageInfo

type Zone struct {
	Src                  string            `protobuf:"bytes,1,opt,name=Src,proto3" json:"Src,omitempty"`
	Dst                  map[string]uint32 `protobuf:"bytes,2,rep,name=Dst,proto3" json:"Dst,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Zone) Reset()         { *m = Zone{} }
func (m *Zone) String() string { return proto.CompactTextString(m) }
func (*Zone) ProtoMessage()    {}
func (*Zone) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e7ff60feb39c8d0, []int{1}
}
func (m *Zone) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Zone) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Zone.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Zone) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Zone.Merge(m, src)
}
func (m *Zone) XXX_Size() int {
	return m.Size()
}
func (m *Zone) XXX_DiscardUnknown() {
	xxx_messageInfo_Zone.DiscardUnknown(m)
}

var xxx_messageInfo_Zone proto.InternalMessageInfo

type Node struct {
	Addr                 string   `protobuf:"bytes,1,opt,name=Addr,proto3" json:"Addr,omitempty"`
	Status               uint32   `protobuf:"varint,2,opt,name=Status,proto3" json:"Status,omitempty"`
	Zone                 string   `protobuf:"bytes,3,opt,name=Zone,proto3" json:"Zone,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e7ff60feb39c8d0, []int{2}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

type RespNodes struct {
	Notes                []*Node  `protobuf:"bytes,1,rep,name=Notes,proto3" json:"Notes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RespNodes) Reset()         { *m = RespNodes{} }
func (m *RespNodes) String() string { return proto.CompactTextString(m) }
func (*RespNodes) ProtoMessage()    {}
func (*RespNodes) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e7ff60feb39c8d0, []int{3}
}
func (m *RespNodes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RespNodes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RespNodes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RespNodes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RespNodes.Merge(m, src)
}
func (m *RespNodes) XXX_Size() int {
	return m.Size()
}
func (m *RespNodes) XXX_DiscardUnknown() {
	xxx_messageInfo_RespNodes.DiscardUnknown(m)
}

var xxx_messageInfo_RespNodes proto.InternalMessageInfo

type Instance struct {
	Region               string            `protobuf:"bytes,1,opt,name=Region,proto3" json:"Region,omitempty"`
	Zone                 string            `protobuf:"bytes,2,opt,name=Zone,proto3" json:"Zone,omitempty"`
	Env                  string            `protobuf:"bytes,3,opt,name=Env,proto3" json:"Env,omitempty"`
	AppID                string            `protobuf:"bytes,4,opt,name=AppID,proto3" json:"AppID,omitempty"`
	Hostname             string            `protobuf:"bytes,5,opt,name=Hostname,proto3" json:"Hostname,omitempty"`
	Addrs                []string          `protobuf:"bytes,6,rep,name=Addrs,proto3" json:"Addrs,omitempty"`
	Status               uint32            `protobuf:"varint,7,opt,name=Status,proto3" json:"Status,omitempty"`
	Version              string            `protobuf:"bytes,8,opt,name=Version,proto3" json:"Version,omitempty"`
	Metadata             map[string]string `protobuf:"bytes,9,rep,name=Metadata,proto3" json:"Metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	RegTimestamp         int64             `protobuf:"varint,10,opt,name=RegTimestamp,proto3" json:"RegTimestamp,omitempty"`
	UpTimestamp          int64             `protobuf:"varint,11,opt,name=UpTimestamp,proto3" json:"UpTimestamp,omitempty"`
	RenewTimestamp       int64             `protobuf:"varint,12,opt,name=RenewTimestamp,proto3" json:"RenewTimestamp,omitempty"`
	DirtyTimestamp       int64             `protobuf:"varint,13,opt,name=DirtyTimestamp,proto3" json:"DirtyTimestamp,omitempty"`
	LatestTimestamp      int64             `protobuf:"varint,14,opt,name=LatestTimestamp,proto3" json:"LatestTimestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Instance) Reset()         { *m = Instance{} }
func (m *Instance) String() string { return proto.CompactTextString(m) }
func (*Instance) ProtoMessage()    {}
func (*Instance) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e7ff60feb39c8d0, []int{4}
}
func (m *Instance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Instance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Instance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Instance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Instance.Merge(m, src)
}
func (m *Instance) XXX_Size() int {
	return m.Size()
}
func (m *Instance) XXX_DiscardUnknown() {
	xxx_messageInfo_Instance.DiscardUnknown(m)
}

var xxx_messageInfo_Instance proto.InternalMessageInfo

type App struct {
	AppID                string               `protobuf:"bytes,1,opt,name=AppID,proto3" json:"AppID,omitempty"`
	Zone                 string               `protobuf:"bytes,2,opt,name=Zone,proto3" json:"Zone,omitempty"`
	Instances            map[string]*Instance `protobuf:"bytes,3,rep,name=instances,proto3" json:"instances,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	LatestTimestamp      int64                `protobuf:"varint,4,opt,name=latestTimestamp,proto3" json:"latestTimestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *App) Reset()         { *m = App{} }
func (m *App) String() string { return proto.CompactTextString(m) }
func (*App) ProtoMessage()    {}
func (*App) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e7ff60feb39c8d0, []int{5}
}
func (m *App) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *App) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_App.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *App) XXX_Merge(src proto.Message) {
	xxx_messageInfo_App.Merge(m, src)
}
func (m *App) XXX_Size() int {
	return m.Size()
}
func (m *App) XXX_DiscardUnknown() {
	xxx_messageInfo_App.DiscardUnknown(m)
}

var xxx_messageInfo_App proto.InternalMessageInfo

type Apps struct {
	Apps                 map[string]*App `protobuf:"bytes,1,rep,name=apps,proto3" json:"apps,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	LatestTimestamp      int64           `protobuf:"varint,2,opt,name=latestTimestamp,proto3" json:"latestTimestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Apps) Reset()         { *m = Apps{} }
func (m *Apps) String() string { return proto.CompactTextString(m) }
func (*Apps) ProtoMessage()    {}
func (*Apps) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e7ff60feb39c8d0, []int{6}
}
func (m *Apps) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Apps) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Apps.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Apps) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Apps.Merge(m, src)
}
func (m *Apps) XXX_Size() int {
	return m.Size()
}
func (m *Apps) XXX_DiscardUnknown() {
	xxx_messageInfo_Apps.DiscardUnknown(m)
}

var xxx_messageInfo_Apps proto.InternalMessageInfo

type Instances struct {
	Instances            []*Instance `protobuf:"bytes,1,rep,name=Instances,proto3" json:"Instances,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Instances) Reset()         { *m = Instances{} }
func (m *Instances) String() string { return proto.CompactTextString(m) }
func (*Instances) ProtoMessage()    {}
func (*Instances) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e7ff60feb39c8d0, []int{7}
}
func (m *Instances) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Instances) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Instances.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Instances) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Instances.Merge(m, src)
}
func (m *Instances) XXX_Size() int {
	return m.Size()
}
func (m *Instances) XXX_DiscardUnknown() {
	xxx_messageInfo_Instances.DiscardUnknown(m)
}

var xxx_messageInfo_Instances proto.InternalMessageInfo

type InstanceInfo struct {
	Instance             map[string]*Instances `protobuf:"bytes,1,rep,name=Instance,proto3" json:"Instance,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Scheduler            []*Zone               `protobuf:"bytes,2,rep,name=Scheduler,proto3" json:"Scheduler,omitempty"`
	LatestTimestamp      int64                 `protobuf:"varint,3,opt,name=LatestTimestamp,proto3" json:"LatestTimestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *InstanceInfo) Reset()         { *m = InstanceInfo{} }
func (m *InstanceInfo) String() string { return proto.CompactTextString(m) }
func (*InstanceInfo) ProtoMessage()    {}
func (*InstanceInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e7ff60feb39c8d0, []int{8}
}
func (m *InstanceInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstanceInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceInfo.Merge(m, src)
}
func (m *InstanceInfo) XXX_Size() int {
	return m.Size()
}
func (m *InstanceInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceInfo.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceInfo proto.InternalMessageInfo

type RespFech struct {
	Code                 float64       `protobuf:"fixed64,1,opt,name=code,proto3" json:"code,omitempty"`
	Data                 *InstanceInfo `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
	LatestTimestamp      uint64        `protobuf:"varint,3,opt,name=LatestTimestamp,proto3" json:"LatestTimestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *RespFech) Reset()         { *m = RespFech{} }
func (m *RespFech) String() string { return proto.CompactTextString(m) }
func (*RespFech) ProtoMessage()    {}
func (*RespFech) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e7ff60feb39c8d0, []int{9}
}
func (m *RespFech) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RespFech) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RespFech.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RespFech) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RespFech.Merge(m, src)
}
func (m *RespFech) XXX_Size() int {
	return m.Size()
}
func (m *RespFech) XXX_DiscardUnknown() {
	xxx_messageInfo_RespFech.DiscardUnknown(m)
}

var xxx_messageInfo_RespFech proto.InternalMessageInfo

type RespFechs struct {
	Code                 float64                  `protobuf:"fixed64,1,opt,name=code,proto3" json:"code,omitempty"`
	Data                 map[string]*InstanceInfo `protobuf:"bytes,2,rep,name=Data,proto3" json:"Data,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	LatestTimestamp      uint64                   `protobuf:"varint,3,opt,name=LatestTimestamp,proto3" json:"LatestTimestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *RespFechs) Reset()         { *m = RespFechs{} }
func (m *RespFechs) String() string { return proto.CompactTextString(m) }
func (*RespFechs) ProtoMessage()    {}
func (*RespFechs) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e7ff60feb39c8d0, []int{10}
}
func (m *RespFechs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RespFechs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RespFechs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RespFechs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RespFechs.Merge(m, src)
}
func (m *RespFechs) XXX_Size() int {
	return m.Size()
}
func (m *RespFechs) XXX_DiscardUnknown() {
	xxx_messageInfo_RespFechs.DiscardUnknown(m)
}

var xxx_messageInfo_RespFechs proto.InternalMessageInfo

type RespNodes struct {
	Code                 float64          `protobuf:"fixed64,1,opt,name=code,proto3" json:"code,omitempty"`
	Data                 map[string]*Node `protobuf:"bytes,2,rep,name=Data,proto3" json:"Data,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	LatestTimestamp      uint64           `protobuf:"varint,3,opt,name=LatestTimestamp,proto3" json:"LatestTimestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *RespNodes) Reset()         { *m = RespNodes{} }
func (m *RespNodes) String() string { return proto.CompactTextString(m) }
func (*RespNodes) ProtoMessage()    {}
func (*RespNodes) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e7ff60feb39c8d0, []int{11}
}
func (m *RespNodes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RespNodes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RespNodes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RespNodes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RespNodes.Merge(m, src)
}
func (m *RespNodes) XXX_Size() int {
	return m.Size()
}
func (m *RespNodes) XXX_DiscardUnknown() {
	xxx_messageInfo_RespNodes.DiscardUnknown(m)
}

var xxx_messageInfo_RespNodes proto.InternalMessageInfo

type ArgRegister struct {
	Region               string   `protobuf:"bytes,1,opt,name=Region,proto3" json:"Region,omitempty"`
	Zone                 string   `protobuf:"bytes,2,opt,name=Zone,proto3" json:"Zone,omitempty"`
	Env                  string   `protobuf:"bytes,3,opt,name=Env,proto3" json:"Env,omitempty"`
	AppID                string   `protobuf:"bytes,4,opt,name=AppID,proto3" json:"AppID,omitempty"`
	Hostname             string   `protobuf:"bytes,5,opt,name=Hostname,proto3" json:"Hostname,omitempty"`
	Status               uint32   `protobuf:"varint,6,opt,name=Status,proto3" json:"Status,omitempty"`
	Addrs                []string `protobuf:"bytes,7,rep,name=Addrs,proto3" json:"Addrs,omitempty"`
	Version              string   `protobuf:"bytes,8,opt,name=Version,proto3" json:"Version,omitempty"`
	Metadata             string   `protobuf:"bytes,9,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	Replication          bool     `protobuf:"varint,10,opt,name=Replication,proto3" json:"Replication,omitempty"`
	LatestTimestamp      int64    `protobuf:"varint,11,opt,name=LatestTimestamp,proto3" json:"LatestTimestamp,omitempty"`
	DirtyTimestamp       int64    `protobuf:"varint,12,opt,name=DirtyTimestamp,proto3" json:"DirtyTimestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArgRegister) Reset()         { *m = ArgRegister{} }
func (m *ArgRegister) String() string { return proto.CompactTextString(m) }
func (*ArgRegister) ProtoMessage()    {}
func (*ArgRegister) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e7ff60feb39c8d0, []int{12}
}
func (m *ArgRegister) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArgRegister) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArgRegister.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArgRegister) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArgRegister.Merge(m, src)
}
func (m *ArgRegister) XXX_Size() int {
	return m.Size()
}
func (m *ArgRegister) XXX_DiscardUnknown() {
	xxx_messageInfo_ArgRegister.DiscardUnknown(m)
}

var xxx_messageInfo_ArgRegister proto.InternalMessageInfo

type ArgRenew struct {
	Zone                 string   `protobuf:"bytes,1,opt,name=Zone,proto3" json:"Zone,omitempty"`
	Env                  string   `protobuf:"bytes,2,opt,name=Env,proto3" json:"Env,omitempty"`
	AppID                string   `protobuf:"bytes,3,opt,name=AppID,proto3" json:"AppID,omitempty"`
	Hostname             string   `protobuf:"bytes,4,opt,name=Hostname,proto3" json:"Hostname,omitempty"`
	Replication          bool     `protobuf:"varint,5,opt,name=Replication,proto3" json:"Replication,omitempty"`
	DirtyTimestamp       int64    `protobuf:"varint,6,opt,name=DirtyTimestamp,proto3" json:"DirtyTimestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArgRenew) Reset()         { *m = ArgRenew{} }
func (m *ArgRenew) String() string { return proto.CompactTextString(m) }
func (*ArgRenew) ProtoMessage()    {}
func (*ArgRenew) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e7ff60feb39c8d0, []int{13}
}
func (m *ArgRenew) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArgRenew) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArgRenew.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArgRenew) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArgRenew.Merge(m, src)
}
func (m *ArgRenew) XXX_Size() int {
	return m.Size()
}
func (m *ArgRenew) XXX_DiscardUnknown() {
	xxx_messageInfo_ArgRenew.DiscardUnknown(m)
}

var xxx_messageInfo_ArgRenew proto.InternalMessageInfo

type ArgCancel struct {
	Zone                 string   `protobuf:"bytes,1,opt,name=Zone,proto3" json:"Zone,omitempty"`
	Env                  string   `protobuf:"bytes,2,opt,name=Env,proto3" json:"Env,omitempty"`
	AppID                string   `protobuf:"bytes,3,opt,name=AppID,proto3" json:"AppID,omitempty"`
	Hostname             string   `protobuf:"bytes,4,opt,name=Hostname,proto3" json:"Hostname,omitempty"`
	Replication          bool     `protobuf:"varint,5,opt,name=Replication,proto3" json:"Replication,omitempty"`
	LatestTimestamp      int64    `protobuf:"varint,6,opt,name=LatestTimestamp,proto3" json:"LatestTimestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArgCancel) Reset()         { *m = ArgCancel{} }
func (m *ArgCancel) String() string { return proto.CompactTextString(m) }
func (*ArgCancel) ProtoMessage()    {}
func (*ArgCancel) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e7ff60feb39c8d0, []int{14}
}
func (m *ArgCancel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArgCancel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArgCancel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArgCancel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArgCancel.Merge(m, src)
}
func (m *ArgCancel) XXX_Size() int {
	return m.Size()
}
func (m *ArgCancel) XXX_DiscardUnknown() {
	xxx_messageInfo_ArgCancel.DiscardUnknown(m)
}

var xxx_messageInfo_ArgCancel proto.InternalMessageInfo

type ArgFetch struct {
	Zone                 string   `protobuf:"bytes,1,opt,name=Zone,proto3" json:"Zone,omitempty"`
	Env                  string   `protobuf:"bytes,2,opt,name=Env,proto3" json:"Env,omitempty"`
	AppID                string   `protobuf:"bytes,3,opt,name=AppID,proto3" json:"AppID,omitempty"`
	Status               uint32   `protobuf:"varint,4,opt,name=Status,proto3" json:"Status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArgFetch) Reset()         { *m = ArgFetch{} }
func (m *ArgFetch) String() string { return proto.CompactTextString(m) }
func (*ArgFetch) ProtoMessage()    {}
func (*ArgFetch) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e7ff60feb39c8d0, []int{15}
}
func (m *ArgFetch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArgFetch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArgFetch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArgFetch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArgFetch.Merge(m, src)
}
func (m *ArgFetch) XXX_Size() int {
	return m.Size()
}
func (m *ArgFetch) XXX_DiscardUnknown() {
	xxx_messageInfo_ArgFetch.DiscardUnknown(m)
}

var xxx_messageInfo_ArgFetch proto.InternalMessageInfo

type ArgFetchs struct {
	Zone                 string   `protobuf:"bytes,1,opt,name=Zone,proto3" json:"Zone,omitempty"`
	Env                  string   `protobuf:"bytes,2,opt,name=Env,proto3" json:"Env,omitempty"`
	AppID                []string `protobuf:"bytes,3,rep,name=AppID,proto3" json:"AppID,omitempty"`
	Status               uint32   `protobuf:"varint,4,opt,name=Status,proto3" json:"Status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArgFetchs) Reset()         { *m = ArgFetchs{} }
func (m *ArgFetchs) String() string { return proto.CompactTextString(m) }
func (*ArgFetchs) ProtoMessage()    {}
func (*ArgFetchs) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e7ff60feb39c8d0, []int{16}
}
func (m *ArgFetchs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArgFetchs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArgFetchs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArgFetchs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArgFetchs.Merge(m, src)
}
func (m *ArgFetchs) XXX_Size() int {
	return m.Size()
}
func (m *ArgFetchs) XXX_DiscardUnknown() {
	xxx_messageInfo_ArgFetchs.DiscardUnknown(m)
}

var xxx_messageInfo_ArgFetchs proto.InternalMessageInfo

type ArgRoll struct {
	Zone                 string   `protobuf:"bytes,1,opt,name=Zone,proto3" json:"Zone,omitempty"`
	Env                  string   `protobuf:"bytes,2,opt,name=Env,proto3" json:"Env,omitempty"`
	AppID                string   `protobuf:"bytes,3,opt,name=AppID,proto3" json:"AppID,omitempty"`
	Hostname             string   `protobuf:"bytes,4,opt,name=Hostname,proto3" json:"Hostname,omitempty"`
	LatestTimestamp      int64    `protobuf:"varint,5,opt,name=LatestTimestamp,proto3" json:"LatestTimestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArgRoll) Reset()         { *m = ArgRoll{} }
func (m *ArgRoll) String() string { return proto.CompactTextString(m) }
func (*ArgRoll) ProtoMessage()    {}
func (*ArgRoll) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e7ff60feb39c8d0, []int{17}
}
func (m *ArgRoll) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArgRoll) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArgRoll.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArgRoll) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArgRoll.Merge(m, src)
}
func (m *ArgRoll) XXX_Size() int {
	return m.Size()
}
func (m *ArgRoll) XXX_DiscardUnknown() {
	xxx_messageInfo_ArgRoll.DiscardUnknown(m)
}

var xxx_messageInfo_ArgRoll proto.InternalMessageInfo

type ArgRolls struct {
	Zone                 string   `protobuf:"bytes,1,opt,name=Zone,proto3" json:"Zone,omitempty"`
	Env                  string   `protobuf:"bytes,2,opt,name=Env,proto3" json:"Env,omitempty"`
	AppID                []string `protobuf:"bytes,3,rep,name=AppID,proto3" json:"AppID,omitempty"`
	Hostname             string   `protobuf:"bytes,4,opt,name=Hostname,proto3" json:"Hostname,omitempty"`
	LatestTimestamp      []int64  `protobuf:"varint,5,rep,packed,name=LatestTimestamp,proto3" json:"LatestTimestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ArgRolls) Reset()         { *m = ArgRolls{} }
func (m *ArgRolls) String() string { return proto.CompactTextString(m) }
func (*ArgRolls) ProtoMessage()    {}
func (*ArgRolls) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e7ff60feb39c8d0, []int{18}
}
func (m *ArgRolls) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArgRolls) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArgRolls.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArgRolls) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArgRolls.Merge(m, src)
}
func (m *ArgRolls) XXX_Size() int {
	return m.Size()
}
func (m *ArgRolls) XXX_DiscardUnknown() {
	xxx_messageInfo_ArgRolls.DiscardUnknown(m)
}

var xxx_messageInfo_ArgRolls proto.InternalMessageInfo

type ArqSet struct {
	Zone                 string    `protobuf:"bytes,1,opt,name=Zone,proto3" json:"Zone,omitempty"`
	Env                  string    `protobuf:"bytes,2,opt,name=Env,proto3" json:"Env,omitempty"`
	AppID                string    `protobuf:"bytes,3,opt,name=AppID,proto3" json:"AppID,omitempty"`
	Hostname             []string  `protobuf:"bytes,4,rep,name=Hostname,proto3" json:"Hostname,omitempty"`
	Status               []float32 `protobuf:"fixed32,5,rep,packed,name=Status,proto3" json:"Status,omitempty"`
	Metadata             []string  `protobuf:"bytes,6,rep,name=Metadata,proto3" json:"Metadata,omitempty"`
	Replication          bool      `protobuf:"varint,7,opt,name=Replication,proto3" json:"Replication,omitempty"`
	SetTimestamp         float64   `protobuf:"fixed64,8,opt,name=SetTimestamp,proto3" json:"SetTimestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ArqSet) Reset()         { *m = ArqSet{} }
func (m *ArqSet) String() string { return proto.CompactTextString(m) }
func (*ArqSet) ProtoMessage()    {}
func (*ArqSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e7ff60feb39c8d0, []int{19}
}
func (m *ArqSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArqSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArqSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArqSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArqSet.Merge(m, src)
}
func (m *ArqSet) XXX_Size() int {
	return m.Size()
}
func (m *ArqSet) XXX_DiscardUnknown() {
	xxx_messageInfo_ArqSet.DiscardUnknown(m)
}

var xxx_messageInfo_ArqSet proto.InternalMessageInfo

func init() {
	proto.RegisterType((*RespMsg)(nil), "gopkg.in.srcd.proteus.v1.example.RespMsg")
	proto.RegisterType((*Zone)(nil), "gopkg.in.srcd.proteus.v1.example.Zone")
	proto.RegisterMapType((map[string]uint32)(nil), "gopkg.in.srcd.proteus.v1.example.Zone.DstEntry")
	proto.RegisterType((*Node)(nil), "gopkg.in.srcd.proteus.v1.example.Node")
	proto.RegisterType((*RespNodes)(nil), "gopkg.in.srcd.proteus.v1.example.respNodes")
	proto.RegisterType((*Instance)(nil), "gopkg.in.srcd.proteus.v1.example.Instance")
	proto.RegisterMapType((map[string]string)(nil), "gopkg.in.srcd.proteus.v1.example.Instance.MetadataEntry")
	proto.RegisterType((*App)(nil), "gopkg.in.srcd.proteus.v1.example.App")
	proto.RegisterMapType((map[string]*Instance)(nil), "gopkg.in.srcd.proteus.v1.example.App.InstancesEntry")
	proto.RegisterType((*Apps)(nil), "gopkg.in.srcd.proteus.v1.example.Apps")
	proto.RegisterMapType((map[string]*App)(nil), "gopkg.in.srcd.proteus.v1.example.Apps.AppsEntry")
	proto.RegisterType((*Instances)(nil), "gopkg.in.srcd.proteus.v1.example.Instances")
	proto.RegisterType((*InstanceInfo)(nil), "gopkg.in.srcd.proteus.v1.example.InstanceInfo")
	proto.RegisterMapType((map[string]*Instances)(nil), "gopkg.in.srcd.proteus.v1.example.InstanceInfo.InstanceEntry")
	proto.RegisterType((*RespFech)(nil), "gopkg.in.srcd.proteus.v1.example.RespFech")
	proto.RegisterType((*RespFechs)(nil), "gopkg.in.srcd.proteus.v1.example.RespFechs")
	proto.RegisterMapType((map[string]*InstanceInfo)(nil), "gopkg.in.srcd.proteus.v1.example.RespFechs.DataEntry")
	proto.RegisterType((*RespNodes)(nil), "gopkg.in.srcd.proteus.v1.example.RespNodes")
	proto.RegisterMapType((map[string]*Node)(nil), "gopkg.in.srcd.proteus.v1.example.RespNodes.DataEntry")
	proto.RegisterType((*ArgRegister)(nil), "gopkg.in.srcd.proteus.v1.example.ArgRegister")
	proto.RegisterType((*ArgRenew)(nil), "gopkg.in.srcd.proteus.v1.example.ArgRenew")
	proto.RegisterType((*ArgCancel)(nil), "gopkg.in.srcd.proteus.v1.example.ArgCancel")
	proto.RegisterType((*ArgFetch)(nil), "gopkg.in.srcd.proteus.v1.example.ArgFetch")
	proto.RegisterType((*ArgFetchs)(nil), "gopkg.in.srcd.proteus.v1.example.ArgFetchs")
	proto.RegisterType((*ArgRoll)(nil), "gopkg.in.srcd.proteus.v1.example.ArgRoll")
	proto.RegisterType((*ArgRolls)(nil), "gopkg.in.srcd.proteus.v1.example.ArgRolls")
	proto.RegisterType((*ArqSet)(nil), "gopkg.in.srcd.proteus.v1.example.ArqSet")
}

func init() { proto.RegisterFile("discovery.proto", fileDescriptor_1e7ff60feb39c8d0) }

var fileDescriptor_1e7ff60feb39c8d0 = []byte{
	// 1247 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0xcd, 0x6f, 0xdc, 0x44,
	0x14, 0xcf, 0xac, 0xbd, 0x1f, 0x7e, 0x9b, 0x0f, 0x34, 0x42, 0xc8, 0xda, 0xc3, 0xb2, 0x8a, 0x44,
	0xb4, 0x24, 0xaa, 0x13, 0x02, 0x45, 0x55, 0x9b, 0x03, 0x6e, 0x9d, 0xaa, 0x91, 0x9a, 0x52, 0x39,
	0x05, 0xa1, 0x20, 0xb5, 0x75, 0xd6, 0x53, 0x67, 0x95, 0x8d, 0x6d, 0x3c, 0xde, 0x84, 0x5c, 0xe1,
	0xc2, 0x95, 0x9e, 0x40, 0x08, 0x89, 0x23, 0x67, 0x24, 0x24, 0x8e, 0x1c, 0x73, 0xe4, 0x0e, 0x87,
	0x64, 0xf9, 0x07, 0xb8, 0x73, 0x41, 0x33, 0x9e, 0xb5, 0xd7, 0xbb, 0xde, 0xac, 0x4d, 0x5b, 0xb8,
	0x54, 0x33, 0xd3, 0xf7, 0xf1, 0xfb, 0xfd, 0xde, 0xcc, 0xf3, 0xdb, 0xc0, 0x92, 0xdd, 0xa5, 0x1d,
	0xef, 0x84, 0x04, 0x67, 0x9a, 0x1f, 0x78, 0xa1, 0x87, 0x5b, 0x8e, 0xe7, 0x1f, 0x39, 0x5a, 0xd7,
	0xd5, 0x68, 0xd0, 0xb1, 0xf9, 0x21, 0xe9, 0x53, 0xed, 0xe4, 0x1d, 0x8d, 0x7c, 0x6e, 0x1d, 0xfb,
	0x3d, 0xd2, 0xb8, 0xe6, 0x74, 0xc3, 0xc3, 0xfe, 0x81, 0xd6, 0xf1, 0x8e, 0xd7, 0x1d, 0xcf, 0xf1,
	0xd6, 0xb9, 0xe3, 0x41, 0xff, 0x19, 0xdf, 0xf1, 0x0d, 0x5f, 0x45, 0x01, 0x97, 0xaf, 0x43, 0xd5,
	0x24, 0xd4, 0xdf, 0xa5, 0x0e, 0xc6, 0x20, 0xdf, 0xf1, 0x6c, 0xa2, 0xa2, 0x16, 0x6a, 0x97, 0x4d,
	0xbe, 0xc6, 0xaf, 0x81, 0xb4, 0x4b, 0x1d, 0xb5, 0xd4, 0x42, 0x6d, 0xc5, 0x64, 0xcb, 0x9b, 0xf2,
	0x57, 0x3f, 0xbc, 0x39, 0xb7, 0xfc, 0x2d, 0x02, 0x79, 0xdf, 0x73, 0xb9, 0xc1, 0x5e, 0xd0, 0xe1,
	0x3e, 0x8a, 0xc9, 0x96, 0x58, 0x07, 0xc9, 0xa0, 0xa1, 0x5a, 0x6a, 0x49, 0xed, 0xfa, 0xe6, 0xba,
	0x36, 0x0b, 0xb0, 0xc6, 0xc2, 0x68, 0x06, 0x0d, 0xb7, 0xdd, 0x30, 0x38, 0x33, 0x99, 0x6f, 0xe3,
	0x7d, 0xa8, 0x0d, 0x0f, 0x58, 0x82, 0x23, 0x72, 0x36, 0x4c, 0x70, 0x44, 0xce, 0xf0, 0xeb, 0x50,
	0x3e, 0xb1, 0x7a, 0x7d, 0xc2, 0x51, 0x2d, 0x98, 0xd1, 0xe6, 0x66, 0xe9, 0x06, 0x12, 0xd8, 0xee,
	0x83, 0xfc, 0x80, 0x61, 0xc7, 0x20, 0xeb, 0xb6, 0x1d, 0x08, 0x57, 0xbe, 0xc6, 0x6f, 0x40, 0x65,
	0x2f, 0xb4, 0xc2, 0x3e, 0x15, 0xce, 0x62, 0xc7, 0x6c, 0x19, 0x0e, 0x55, 0x8a, 0x6c, 0xd9, 0x5a,
	0x44, 0xfb, 0x10, 0x94, 0x80, 0x50, 0x9f, 0x45, 0xa4, 0x78, 0x0b, 0xca, 0x0f, 0xbc, 0x90, 0x50,
	0x15, 0x71, 0x76, 0x2b, 0xb3, 0xd9, 0x31, 0x3f, 0x33, 0x72, 0x12, 0x01, 0xbf, 0x93, 0xa1, 0xb6,
	0xe3, 0xd2, 0xd0, 0x72, 0x3b, 0x84, 0xe1, 0x31, 0x89, 0xd3, 0xf5, 0x5c, 0x81, 0x52, 0xec, 0x62,
	0x3c, 0xa5, 0x04, 0x0f, 0x53, 0x62, 0xdb, 0x3d, 0x11, 0x10, 0xd9, 0x92, 0x29, 0xa1, 0xfb, 0xfe,
	0x8e, 0xa1, 0xca, 0xfc, 0x2c, 0xda, 0xe0, 0x06, 0xd4, 0xee, 0x79, 0x34, 0x74, 0xad, 0x63, 0xa2,
	0x96, 0xf9, 0x7f, 0xc4, 0x7b, 0xee, 0x61, 0xdb, 0x01, 0x55, 0x2b, 0x2d, 0x89, 0x7b, 0xb0, 0xcd,
	0x88, 0x2a, 0xd5, 0x94, 0x2a, 0x2a, 0x54, 0x3f, 0x26, 0x01, 0x65, 0xf0, 0x6a, 0x3c, 0xd0, 0x70,
	0x8b, 0x1f, 0x41, 0x6d, 0x97, 0x84, 0x96, 0x6d, 0x85, 0x96, 0xaa, 0x70, 0x2d, 0x6e, 0xcc, 0xd6,
	0x62, 0xc8, 0x5a, 0x1b, 0xba, 0x46, 0x25, 0x8f, 0x23, 0xe1, 0x65, 0x98, 0x37, 0x89, 0xf3, 0xa8,
	0x7b, 0x4c, 0x68, 0x68, 0x1d, 0xfb, 0x2a, 0xb4, 0x50, 0x5b, 0x32, 0x53, 0x67, 0xb8, 0x05, 0xf5,
	0x8f, 0xfc, 0xc4, 0xa4, 0xce, 0x4d, 0x46, 0x8f, 0xf0, 0x0a, 0x2c, 0x9a, 0xc4, 0x25, 0xa7, 0x89,
	0xd1, 0x3c, 0x37, 0x1a, 0x3b, 0x65, 0x76, 0x46, 0x37, 0x08, 0xcf, 0x12, 0xbb, 0x85, 0xc8, 0x2e,
	0x7d, 0x8a, 0xdb, 0xb0, 0x74, 0xdf, 0x0a, 0x09, 0x0d, 0x13, 0xc3, 0x45, 0x6e, 0x38, 0x7e, 0xdc,
	0xb8, 0x05, 0x0b, 0x29, 0x6a, 0xb3, 0x2e, 0xaf, 0x32, 0x79, 0x79, 0xbf, 0x2f, 0x81, 0xa4, 0xfb,
	0x7e, 0x52, 0x5a, 0x34, 0x5a, 0xda, 0xac, 0x6b, 0x61, 0x82, 0xd2, 0x15, 0xc2, 0x52, 0x55, 0xe2,
	0xb5, 0x78, 0x6f, 0x76, 0x2d, 0x74, 0xdf, 0x8f, 0xeb, 0x41, 0xa3, 0x3a, 0x24, 0x61, 0x18, 0xe5,
	0xde, 0x18, 0x65, 0x39, 0xa2, 0x3c, 0x76, 0xdc, 0x38, 0x84, 0xc5, 0x74, 0x98, 0x0c, 0xce, 0x1f,
	0x8c, 0x72, 0xae, 0x6f, 0xae, 0xe6, 0xbf, 0x29, 0x93, 0xfa, 0xfc, 0x81, 0x40, 0xd6, 0x7d, 0x9f,
	0x62, 0x03, 0x64, 0xcb, 0xf7, 0x87, 0x2f, 0x71, 0x23, 0x17, 0x63, 0xca, 0xff, 0x89, 0xd8, 0x72,
	0xef, 0x2c, 0xa2, 0xa5, 0x6c, 0xa2, 0x8f, 0x41, 0x89, 0x9d, 0x33, 0x38, 0xde, 0x4a, 0x73, 0x7c,
	0x2b, 0x17, 0x9e, 0x49, 0x7a, 0x9f, 0x82, 0x12, 0xcb, 0x89, 0xef, 0x8d, 0x6c, 0x04, 0xcf, 0x22,
	0xda, 0x25, 0xce, 0x22, 0xf8, 0x79, 0x09, 0xe6, 0x87, 0x67, 0x3b, 0xee, 0x33, 0x0f, 0x7f, 0x92,
	0x74, 0x22, 0x11, 0x7f, 0x2b, 0x7f, 0x7c, 0x16, 0x21, 0xde, 0x88, 0x97, 0x1c, 0xf7, 0x35, 0x03,
	0x94, 0xbd, 0xce, 0x21, 0xb1, 0xfb, 0x3d, 0x12, 0x88, 0x4f, 0xc1, 0x4a, 0xbe, 0x4f, 0x81, 0x99,
	0x38, 0x66, 0xbd, 0x3c, 0x29, 0xfb, 0xe5, 0x1d, 0xc2, 0x42, 0x0a, 0x4a, 0x46, 0x85, 0xf4, 0x74,
	0x85, 0xd6, 0xf2, 0x33, 0xa5, 0x93, 0x75, 0x7a, 0x8e, 0xa0, 0xc6, 0xbe, 0x9b, 0x77, 0x49, 0xe7,
	0x90, 0xbd, 0xca, 0xce, 0xf0, 0xc3, 0x89, 0x4c, 0xbe, 0xc6, 0xb7, 0x41, 0x36, 0x58, 0x73, 0x8c,
	0x92, 0x69, 0xc5, 0x64, 0x35, 0xb9, 0xef, 0x34, 0xfa, 0xf2, 0x04, 0x7d, 0x01, 0xea, 0xcb, 0x12,
	0x28, 0x43, 0x50, 0x34, 0x13, 0xd5, 0x4e, 0x8c, 0x8a, 0x55, 0xe4, 0xfa, 0x6c, 0x54, 0x71, 0x38,
	0xcd, 0x88, 0xfb, 0x75, 0x41, 0x70, 0x0d, 0x07, 0x14, 0xe3, 0x8a, 0x8e, 0x68, 0xa4, 0xeb, 0x52,
	0x54, 0xaa, 0x89, 0xd2, 0xfc, 0x8d, 0x22, 0x15, 0xa2, 0x2f, 0xf6, 0x4b, 0x53, 0x81, 0x87, 0x7b,
	0x01, 0x15, 0x9e, 0x5c, 0xad, 0xc2, 0x56, 0x5a, 0x85, 0xdc, 0x93, 0xc5, 0x38, 0xfb, 0xdf, 0x4b,
	0x50, 0xd7, 0x03, 0x87, 0x8d, 0x11, 0x34, 0x24, 0xc1, 0x7f, 0x3e, 0x60, 0x24, 0xa3, 0x44, 0x25,
	0x35, 0x4a, 0xc4, 0x83, 0x47, 0x75, 0x74, 0xf0, 0x98, 0x3e, 0x60, 0x34, 0x52, 0x03, 0x06, 0xcf,
	0x11, 0x8f, 0x09, 0x2d, 0xa8, 0x9b, 0xc4, 0xef, 0x75, 0x3b, 0x56, 0xc8, 0x3c, 0xd9, 0x94, 0x50,
	0x33, 0x47, 0x8f, 0xb2, 0xca, 0x52, 0xcf, 0x6c, 0x1c, 0x19, 0x43, 0xc0, 0x7c, 0xd6, 0x10, 0x20,
	0xd4, 0xfd, 0x09, 0x41, 0x8d, 0xab, 0xeb, 0x92, 0xd3, 0x58, 0x42, 0x34, 0x29, 0x61, 0x29, 0x43,
	0x42, 0x69, 0x9a, 0x84, 0xf2, 0x98, 0x84, 0x63, 0xf4, 0xca, 0x93, 0xf4, 0x26, 0x41, 0x57, 0xae,
	0x00, 0xfd, 0x33, 0x02, 0x45, 0x0f, 0x9c, 0x3b, 0xec, 0xc9, 0xf4, 0xfe, 0x47, 0xd4, 0x19, 0x45,
	0xa9, 0x64, 0x16, 0x45, 0xe0, 0xb6, 0xb9, 0xd6, 0x77, 0x49, 0x18, 0xb5, 0xd8, 0x7f, 0x8d, 0x3a,
	0xb9, 0x92, 0xf2, 0xe8, 0x95, 0x14, 0x59, 0x08, 0x17, 0x87, 0x67, 0xa1, 0xc5, 0xd3, 0x48, 0x79,
	0xd3, 0x7c, 0x8d, 0xa0, 0xca, 0x6e, 0x8e, 0xd7, 0x7b, 0x75, 0x25, 0xc8, 0x10, 0xb8, 0x7c, 0x95,
	0xc0, 0xcf, 0xc5, 0x6d, 0xf6, 0x7a, 0xbd, 0x17, 0xa3, 0x5e, 0x18, 0x94, 0x34, 0x1d, 0xd4, 0x05,
	0x82, 0x8a, 0x1e, 0x7c, 0xb6, 0x47, 0xc2, 0x97, 0xa8, 0x93, 0x34, 0xa5, 0x47, 0x31, 0x24, 0xa5,
	0xb8, 0x47, 0x8d, 0xf6, 0x9c, 0xe8, 0xf7, 0xd1, 0xd4, 0x9e, 0x53, 0x9d, 0xbc, 0xde, 0xcb, 0x30,
	0xbf, 0x47, 0x46, 0x58, 0xd6, 0xf8, 0x17, 0x27, 0x75, 0x16, 0x51, 0xdc, 0xfc, 0xa2, 0x0a, 0x4b,
	0xdb, 0xfd, 0x80, 0x1c, 0x59, 0xc6, 0xf0, 0xe7, 0x3d, 0xb6, 0xd9, 0x3c, 0x21, 0x7a, 0xf6, 0xb5,
	0x1c, 0xc3, 0x63, 0xd2, 0xe2, 0x1b, 0x6f, 0xe7, 0xfb, 0x80, 0xb1, 0x9f, 0xf8, 0x8f, 0xa1, 0x1c,
	0xf5, 0xae, 0xd5, 0x9c, 0x29, 0x5c, 0x72, 0x5a, 0x24, 0xfe, 0x53, 0xa8, 0x88, 0x36, 0xb3, 0x96,
	0x2b, 0x41, 0x64, 0x5c, 0x24, 0xc3, 0x13, 0x28, 0x47, 0x1d, 0x21, 0x1f, 0x03, 0x6e, 0xdb, 0x58,
	0xcd, 0x3f, 0xe8, 0xb0, 0x42, 0x70, 0x27, 0xbd, 0x97, 0x97, 0x44, 0xd4, 0x3b, 0x1a, 0x6b, 0x05,
	0xa6, 0x29, 0xfc, 0x14, 0xe4, 0x87, 0xac, 0x15, 0xbc, 0x22, 0x16, 0x1b, 0x08, 0x1f, 0x40, 0xf9,
	0x21, 0x7f, 0xd8, 0x45, 0x52, 0x14, 0xe1, 0xb0, 0x81, 0xd8, 0x75, 0x8a, 0xa6, 0xac, 0x22, 0x39,
	0x0a, 0x14, 0x7b, 0x1f, 0x24, 0xd6, 0x07, 0xda, 0x79, 0xa2, 0xb3, 0x8e, 0x51, 0x20, 0xf6, 0xed,
	0x8d, 0xf3, 0xcb, 0xe6, 0xdc, 0xc5, 0x65, 0x13, 0xfd, 0x75, 0xd9, 0x44, 0x3f, 0x0e, 0x9a, 0xe8,
	0x97, 0x41, 0x13, 0xfd, 0x3a, 0x68, 0xa2, 0xf3, 0x41, 0x13, 0xfd, 0x36, 0x68, 0xa2, 0x8b, 0x41,
	0x13, 0x7d, 0xf3, 0x67, 0x73, 0x6e, 0xbf, 0x42, 0xf8, 0x5b, 0x3d, 0xa8, 0xf0, 0xbf, 0x98, 0xbd,
	0xfb, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x82, 0x2d, 0xb8, 0xaa, 0x95, 0x13, 0x00, 0x00,
}

func (this *RespMsg) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RespMsg)
	if !ok {
		that2, ok := that.(RespMsg)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RespMsg")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RespMsg but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RespMsg but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if this.Msg != that1.Msg {
		return fmt.Errorf("Msg this(%v) Not Equal that(%v)", this.Msg, that1.Msg)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *RespMsg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RespMsg)
	if !ok {
		that2, ok := that.(RespMsg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Msg != that1.Msg {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Zone) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Zone)
	if !ok {
		that2, ok := that.(Zone)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Zone")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Zone but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Zone but is not nil && this == nil")
	}
	if this.Src != that1.Src {
		return fmt.Errorf("Src this(%v) Not Equal that(%v)", this.Src, that1.Src)
	}
	if len(this.Dst) != len(that1.Dst) {
		return fmt.Errorf("Dst this(%v) Not Equal that(%v)", len(this.Dst), len(that1.Dst))
	}
	for i := range this.Dst {
		if this.Dst[i] != that1.Dst[i] {
			return fmt.Errorf("Dst this[%v](%v) Not Equal that[%v](%v)", i, this.Dst[i], i, that1.Dst[i])
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Zone) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Zone)
	if !ok {
		that2, ok := that.(Zone)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Src != that1.Src {
		return false
	}
	if len(this.Dst) != len(that1.Dst) {
		return false
	}
	for i := range this.Dst {
		if this.Dst[i] != that1.Dst[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Node) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Node)
	if !ok {
		that2, ok := that.(Node)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Node")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Node but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Node but is not nil && this == nil")
	}
	if this.Addr != that1.Addr {
		return fmt.Errorf("Addr this(%v) Not Equal that(%v)", this.Addr, that1.Addr)
	}
	if this.Status != that1.Status {
		return fmt.Errorf("Status this(%v) Not Equal that(%v)", this.Status, that1.Status)
	}
	if this.Zone != that1.Zone {
		return fmt.Errorf("Zone this(%v) Not Equal that(%v)", this.Zone, that1.Zone)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Node) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Node)
	if !ok {
		that2, ok := that.(Node)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Addr != that1.Addr {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Zone != that1.Zone {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RespNodes) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RespNodes)
	if !ok {
		that2, ok := that.(RespNodes)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RespNodes")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RespNodes but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RespNodes but is not nil && this == nil")
	}
	if len(this.Notes) != len(that1.Notes) {
		return fmt.Errorf("Notes this(%v) Not Equal that(%v)", len(this.Notes), len(that1.Notes))
	}
	for i := range this.Notes {
		if !this.Notes[i].Equal(that1.Notes[i]) {
			return fmt.Errorf("Notes this[%v](%v) Not Equal that[%v](%v)", i, this.Notes[i], i, that1.Notes[i])
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *RespNodes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RespNodes)
	if !ok {
		that2, ok := that.(RespNodes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Notes) != len(that1.Notes) {
		return false
	}
	for i := range this.Notes {
		if !this.Notes[i].Equal(that1.Notes[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Instance) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Instance)
	if !ok {
		that2, ok := that.(Instance)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Instance")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Instance but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Instance but is not nil && this == nil")
	}
	if this.Region != that1.Region {
		return fmt.Errorf("Region this(%v) Not Equal that(%v)", this.Region, that1.Region)
	}
	if this.Zone != that1.Zone {
		return fmt.Errorf("Zone this(%v) Not Equal that(%v)", this.Zone, that1.Zone)
	}
	if this.Env != that1.Env {
		return fmt.Errorf("Env this(%v) Not Equal that(%v)", this.Env, that1.Env)
	}
	if this.AppID != that1.AppID {
		return fmt.Errorf("AppID this(%v) Not Equal that(%v)", this.AppID, that1.AppID)
	}
	if this.Hostname != that1.Hostname {
		return fmt.Errorf("Hostname this(%v) Not Equal that(%v)", this.Hostname, that1.Hostname)
	}
	if len(this.Addrs) != len(that1.Addrs) {
		return fmt.Errorf("Addrs this(%v) Not Equal that(%v)", len(this.Addrs), len(that1.Addrs))
	}
	for i := range this.Addrs {
		if this.Addrs[i] != that1.Addrs[i] {
			return fmt.Errorf("Addrs this[%v](%v) Not Equal that[%v](%v)", i, this.Addrs[i], i, that1.Addrs[i])
		}
	}
	if this.Status != that1.Status {
		return fmt.Errorf("Status this(%v) Not Equal that(%v)", this.Status, that1.Status)
	}
	if this.Version != that1.Version {
		return fmt.Errorf("Version this(%v) Not Equal that(%v)", this.Version, that1.Version)
	}
	if len(this.Metadata) != len(that1.Metadata) {
		return fmt.Errorf("Metadata this(%v) Not Equal that(%v)", len(this.Metadata), len(that1.Metadata))
	}
	for i := range this.Metadata {
		if this.Metadata[i] != that1.Metadata[i] {
			return fmt.Errorf("Metadata this[%v](%v) Not Equal that[%v](%v)", i, this.Metadata[i], i, that1.Metadata[i])
		}
	}
	if this.RegTimestamp != that1.RegTimestamp {
		return fmt.Errorf("RegTimestamp this(%v) Not Equal that(%v)", this.RegTimestamp, that1.RegTimestamp)
	}
	if this.UpTimestamp != that1.UpTimestamp {
		return fmt.Errorf("UpTimestamp this(%v) Not Equal that(%v)", this.UpTimestamp, that1.UpTimestamp)
	}
	if this.RenewTimestamp != that1.RenewTimestamp {
		return fmt.Errorf("RenewTimestamp this(%v) Not Equal that(%v)", this.RenewTimestamp, that1.RenewTimestamp)
	}
	if this.DirtyTimestamp != that1.DirtyTimestamp {
		return fmt.Errorf("DirtyTimestamp this(%v) Not Equal that(%v)", this.DirtyTimestamp, that1.DirtyTimestamp)
	}
	if this.LatestTimestamp != that1.LatestTimestamp {
		return fmt.Errorf("LatestTimestamp this(%v) Not Equal that(%v)", this.LatestTimestamp, that1.LatestTimestamp)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Instance) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Instance)
	if !ok {
		that2, ok := that.(Instance)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Region != that1.Region {
		return false
	}
	if this.Zone != that1.Zone {
		return false
	}
	if this.Env != that1.Env {
		return false
	}
	if this.AppID != that1.AppID {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	if len(this.Addrs) != len(that1.Addrs) {
		return false
	}
	for i := range this.Addrs {
		if this.Addrs[i] != that1.Addrs[i] {
			return false
		}
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if len(this.Metadata) != len(that1.Metadata) {
		return false
	}
	for i := range this.Metadata {
		if this.Metadata[i] != that1.Metadata[i] {
			return false
		}
	}
	if this.RegTimestamp != that1.RegTimestamp {
		return false
	}
	if this.UpTimestamp != that1.UpTimestamp {
		return false
	}
	if this.RenewTimestamp != that1.RenewTimestamp {
		return false
	}
	if this.DirtyTimestamp != that1.DirtyTimestamp {
		return false
	}
	if this.LatestTimestamp != that1.LatestTimestamp {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *App) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*App)
	if !ok {
		that2, ok := that.(App)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *App")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *App but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *App but is not nil && this == nil")
	}
	if this.AppID != that1.AppID {
		return fmt.Errorf("AppID this(%v) Not Equal that(%v)", this.AppID, that1.AppID)
	}
	if this.Zone != that1.Zone {
		return fmt.Errorf("Zone this(%v) Not Equal that(%v)", this.Zone, that1.Zone)
	}
	if len(this.Instances) != len(that1.Instances) {
		return fmt.Errorf("Instances this(%v) Not Equal that(%v)", len(this.Instances), len(that1.Instances))
	}
	for i := range this.Instances {
		if !this.Instances[i].Equal(that1.Instances[i]) {
			return fmt.Errorf("Instances this[%v](%v) Not Equal that[%v](%v)", i, this.Instances[i], i, that1.Instances[i])
		}
	}
	if this.LatestTimestamp != that1.LatestTimestamp {
		return fmt.Errorf("LatestTimestamp this(%v) Not Equal that(%v)", this.LatestTimestamp, that1.LatestTimestamp)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *App) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*App)
	if !ok {
		that2, ok := that.(App)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AppID != that1.AppID {
		return false
	}
	if this.Zone != that1.Zone {
		return false
	}
	if len(this.Instances) != len(that1.Instances) {
		return false
	}
	for i := range this.Instances {
		if !this.Instances[i].Equal(that1.Instances[i]) {
			return false
		}
	}
	if this.LatestTimestamp != that1.LatestTimestamp {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Apps) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Apps)
	if !ok {
		that2, ok := that.(Apps)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Apps")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Apps but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Apps but is not nil && this == nil")
	}
	if len(this.Apps) != len(that1.Apps) {
		return fmt.Errorf("Apps this(%v) Not Equal that(%v)", len(this.Apps), len(that1.Apps))
	}
	for i := range this.Apps {
		if !this.Apps[i].Equal(that1.Apps[i]) {
			return fmt.Errorf("Apps this[%v](%v) Not Equal that[%v](%v)", i, this.Apps[i], i, that1.Apps[i])
		}
	}
	if this.LatestTimestamp != that1.LatestTimestamp {
		return fmt.Errorf("LatestTimestamp this(%v) Not Equal that(%v)", this.LatestTimestamp, that1.LatestTimestamp)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Apps) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Apps)
	if !ok {
		that2, ok := that.(Apps)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Apps) != len(that1.Apps) {
		return false
	}
	for i := range this.Apps {
		if !this.Apps[i].Equal(that1.Apps[i]) {
			return false
		}
	}
	if this.LatestTimestamp != that1.LatestTimestamp {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Instances) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Instances)
	if !ok {
		that2, ok := that.(Instances)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Instances")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Instances but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Instances but is not nil && this == nil")
	}
	if len(this.Instances) != len(that1.Instances) {
		return fmt.Errorf("Instances this(%v) Not Equal that(%v)", len(this.Instances), len(that1.Instances))
	}
	for i := range this.Instances {
		if !this.Instances[i].Equal(that1.Instances[i]) {
			return fmt.Errorf("Instances this[%v](%v) Not Equal that[%v](%v)", i, this.Instances[i], i, that1.Instances[i])
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Instances) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Instances)
	if !ok {
		that2, ok := that.(Instances)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Instances) != len(that1.Instances) {
		return false
	}
	for i := range this.Instances {
		if !this.Instances[i].Equal(that1.Instances[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *InstanceInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*InstanceInfo)
	if !ok {
		that2, ok := that.(InstanceInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *InstanceInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *InstanceInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *InstanceInfo but is not nil && this == nil")
	}
	if len(this.Instance) != len(that1.Instance) {
		return fmt.Errorf("Instance this(%v) Not Equal that(%v)", len(this.Instance), len(that1.Instance))
	}
	for i := range this.Instance {
		if !this.Instance[i].Equal(that1.Instance[i]) {
			return fmt.Errorf("Instance this[%v](%v) Not Equal that[%v](%v)", i, this.Instance[i], i, that1.Instance[i])
		}
	}
	if len(this.Scheduler) != len(that1.Scheduler) {
		return fmt.Errorf("Scheduler this(%v) Not Equal that(%v)", len(this.Scheduler), len(that1.Scheduler))
	}
	for i := range this.Scheduler {
		if !this.Scheduler[i].Equal(that1.Scheduler[i]) {
			return fmt.Errorf("Scheduler this[%v](%v) Not Equal that[%v](%v)", i, this.Scheduler[i], i, that1.Scheduler[i])
		}
	}
	if this.LatestTimestamp != that1.LatestTimestamp {
		return fmt.Errorf("LatestTimestamp this(%v) Not Equal that(%v)", this.LatestTimestamp, that1.LatestTimestamp)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *InstanceInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InstanceInfo)
	if !ok {
		that2, ok := that.(InstanceInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Instance) != len(that1.Instance) {
		return false
	}
	for i := range this.Instance {
		if !this.Instance[i].Equal(that1.Instance[i]) {
			return false
		}
	}
	if len(this.Scheduler) != len(that1.Scheduler) {
		return false
	}
	for i := range this.Scheduler {
		if !this.Scheduler[i].Equal(that1.Scheduler[i]) {
			return false
		}
	}
	if this.LatestTimestamp != that1.LatestTimestamp {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RespFech) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RespFech)
	if !ok {
		that2, ok := that.(RespFech)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RespFech")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RespFech but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RespFech but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if !this.Data.Equal(that1.Data) {
		return fmt.Errorf("Data this(%v) Not Equal that(%v)", this.Data, that1.Data)
	}
	if this.LatestTimestamp != that1.LatestTimestamp {
		return fmt.Errorf("LatestTimestamp this(%v) Not Equal that(%v)", this.LatestTimestamp, that1.LatestTimestamp)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *RespFech) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RespFech)
	if !ok {
		that2, ok := that.(RespFech)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if !this.Data.Equal(that1.Data) {
		return false
	}
	if this.LatestTimestamp != that1.LatestTimestamp {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RespFechs) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RespFechs)
	if !ok {
		that2, ok := that.(RespFechs)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RespFechs")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RespFechs but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RespFechs but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if len(this.Data) != len(that1.Data) {
		return fmt.Errorf("Data this(%v) Not Equal that(%v)", len(this.Data), len(that1.Data))
	}
	for i := range this.Data {
		if !this.Data[i].Equal(that1.Data[i]) {
			return fmt.Errorf("Data this[%v](%v) Not Equal that[%v](%v)", i, this.Data[i], i, that1.Data[i])
		}
	}
	if this.LatestTimestamp != that1.LatestTimestamp {
		return fmt.Errorf("LatestTimestamp this(%v) Not Equal that(%v)", this.LatestTimestamp, that1.LatestTimestamp)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *RespFechs) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RespFechs)
	if !ok {
		that2, ok := that.(RespFechs)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if len(this.Data) != len(that1.Data) {
		return false
	}
	for i := range this.Data {
		if !this.Data[i].Equal(that1.Data[i]) {
			return false
		}
	}
	if this.LatestTimestamp != that1.LatestTimestamp {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RespNodes) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RespNodes)
	if !ok {
		that2, ok := that.(RespNodes)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RespNodes")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RespNodes but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RespNodes but is not nil && this == nil")
	}
	if this.Code != that1.Code {
		return fmt.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if len(this.Data) != len(that1.Data) {
		return fmt.Errorf("Data this(%v) Not Equal that(%v)", len(this.Data), len(that1.Data))
	}
	for i := range this.Data {
		if !this.Data[i].Equal(that1.Data[i]) {
			return fmt.Errorf("Data this[%v](%v) Not Equal that[%v](%v)", i, this.Data[i], i, that1.Data[i])
		}
	}
	if this.LatestTimestamp != that1.LatestTimestamp {
		return fmt.Errorf("LatestTimestamp this(%v) Not Equal that(%v)", this.LatestTimestamp, that1.LatestTimestamp)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *RespNodes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RespNodes)
	if !ok {
		that2, ok := that.(RespNodes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if len(this.Data) != len(that1.Data) {
		return false
	}
	for i := range this.Data {
		if !this.Data[i].Equal(that1.Data[i]) {
			return false
		}
	}
	if this.LatestTimestamp != that1.LatestTimestamp {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ArgRegister) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ArgRegister)
	if !ok {
		that2, ok := that.(ArgRegister)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ArgRegister")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ArgRegister but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ArgRegister but is not nil && this == nil")
	}
	if this.Region != that1.Region {
		return fmt.Errorf("Region this(%v) Not Equal that(%v)", this.Region, that1.Region)
	}
	if this.Zone != that1.Zone {
		return fmt.Errorf("Zone this(%v) Not Equal that(%v)", this.Zone, that1.Zone)
	}
	if this.Env != that1.Env {
		return fmt.Errorf("Env this(%v) Not Equal that(%v)", this.Env, that1.Env)
	}
	if this.AppID != that1.AppID {
		return fmt.Errorf("AppID this(%v) Not Equal that(%v)", this.AppID, that1.AppID)
	}
	if this.Hostname != that1.Hostname {
		return fmt.Errorf("Hostname this(%v) Not Equal that(%v)", this.Hostname, that1.Hostname)
	}
	if this.Status != that1.Status {
		return fmt.Errorf("Status this(%v) Not Equal that(%v)", this.Status, that1.Status)
	}
	if len(this.Addrs) != len(that1.Addrs) {
		return fmt.Errorf("Addrs this(%v) Not Equal that(%v)", len(this.Addrs), len(that1.Addrs))
	}
	for i := range this.Addrs {
		if this.Addrs[i] != that1.Addrs[i] {
			return fmt.Errorf("Addrs this[%v](%v) Not Equal that[%v](%v)", i, this.Addrs[i], i, that1.Addrs[i])
		}
	}
	if this.Version != that1.Version {
		return fmt.Errorf("Version this(%v) Not Equal that(%v)", this.Version, that1.Version)
	}
	if this.Metadata != that1.Metadata {
		return fmt.Errorf("Metadata this(%v) Not Equal that(%v)", this.Metadata, that1.Metadata)
	}
	if this.Replication != that1.Replication {
		return fmt.Errorf("Replication this(%v) Not Equal that(%v)", this.Replication, that1.Replication)
	}
	if this.LatestTimestamp != that1.LatestTimestamp {
		return fmt.Errorf("LatestTimestamp this(%v) Not Equal that(%v)", this.LatestTimestamp, that1.LatestTimestamp)
	}
	if this.DirtyTimestamp != that1.DirtyTimestamp {
		return fmt.Errorf("DirtyTimestamp this(%v) Not Equal that(%v)", this.DirtyTimestamp, that1.DirtyTimestamp)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *ArgRegister) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ArgRegister)
	if !ok {
		that2, ok := that.(ArgRegister)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Region != that1.Region {
		return false
	}
	if this.Zone != that1.Zone {
		return false
	}
	if this.Env != that1.Env {
		return false
	}
	if this.AppID != that1.AppID {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if len(this.Addrs) != len(that1.Addrs) {
		return false
	}
	for i := range this.Addrs {
		if this.Addrs[i] != that1.Addrs[i] {
			return false
		}
	}
	if this.Version != that1.Version {
		return false
	}
	if this.Metadata != that1.Metadata {
		return false
	}
	if this.Replication != that1.Replication {
		return false
	}
	if this.LatestTimestamp != that1.LatestTimestamp {
		return false
	}
	if this.DirtyTimestamp != that1.DirtyTimestamp {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ArgRenew) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ArgRenew)
	if !ok {
		that2, ok := that.(ArgRenew)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ArgRenew")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ArgRenew but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ArgRenew but is not nil && this == nil")
	}
	if this.Zone != that1.Zone {
		return fmt.Errorf("Zone this(%v) Not Equal that(%v)", this.Zone, that1.Zone)
	}
	if this.Env != that1.Env {
		return fmt.Errorf("Env this(%v) Not Equal that(%v)", this.Env, that1.Env)
	}
	if this.AppID != that1.AppID {
		return fmt.Errorf("AppID this(%v) Not Equal that(%v)", this.AppID, that1.AppID)
	}
	if this.Hostname != that1.Hostname {
		return fmt.Errorf("Hostname this(%v) Not Equal that(%v)", this.Hostname, that1.Hostname)
	}
	if this.Replication != that1.Replication {
		return fmt.Errorf("Replication this(%v) Not Equal that(%v)", this.Replication, that1.Replication)
	}
	if this.DirtyTimestamp != that1.DirtyTimestamp {
		return fmt.Errorf("DirtyTimestamp this(%v) Not Equal that(%v)", this.DirtyTimestamp, that1.DirtyTimestamp)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *ArgRenew) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ArgRenew)
	if !ok {
		that2, ok := that.(ArgRenew)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Zone != that1.Zone {
		return false
	}
	if this.Env != that1.Env {
		return false
	}
	if this.AppID != that1.AppID {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	if this.Replication != that1.Replication {
		return false
	}
	if this.DirtyTimestamp != that1.DirtyTimestamp {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ArgCancel) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ArgCancel)
	if !ok {
		that2, ok := that.(ArgCancel)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ArgCancel")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ArgCancel but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ArgCancel but is not nil && this == nil")
	}
	if this.Zone != that1.Zone {
		return fmt.Errorf("Zone this(%v) Not Equal that(%v)", this.Zone, that1.Zone)
	}
	if this.Env != that1.Env {
		return fmt.Errorf("Env this(%v) Not Equal that(%v)", this.Env, that1.Env)
	}
	if this.AppID != that1.AppID {
		return fmt.Errorf("AppID this(%v) Not Equal that(%v)", this.AppID, that1.AppID)
	}
	if this.Hostname != that1.Hostname {
		return fmt.Errorf("Hostname this(%v) Not Equal that(%v)", this.Hostname, that1.Hostname)
	}
	if this.Replication != that1.Replication {
		return fmt.Errorf("Replication this(%v) Not Equal that(%v)", this.Replication, that1.Replication)
	}
	if this.LatestTimestamp != that1.LatestTimestamp {
		return fmt.Errorf("LatestTimestamp this(%v) Not Equal that(%v)", this.LatestTimestamp, that1.LatestTimestamp)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *ArgCancel) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ArgCancel)
	if !ok {
		that2, ok := that.(ArgCancel)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Zone != that1.Zone {
		return false
	}
	if this.Env != that1.Env {
		return false
	}
	if this.AppID != that1.AppID {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	if this.Replication != that1.Replication {
		return false
	}
	if this.LatestTimestamp != that1.LatestTimestamp {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ArgFetch) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ArgFetch)
	if !ok {
		that2, ok := that.(ArgFetch)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ArgFetch")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ArgFetch but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ArgFetch but is not nil && this == nil")
	}
	if this.Zone != that1.Zone {
		return fmt.Errorf("Zone this(%v) Not Equal that(%v)", this.Zone, that1.Zone)
	}
	if this.Env != that1.Env {
		return fmt.Errorf("Env this(%v) Not Equal that(%v)", this.Env, that1.Env)
	}
	if this.AppID != that1.AppID {
		return fmt.Errorf("AppID this(%v) Not Equal that(%v)", this.AppID, that1.AppID)
	}
	if this.Status != that1.Status {
		return fmt.Errorf("Status this(%v) Not Equal that(%v)", this.Status, that1.Status)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *ArgFetch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ArgFetch)
	if !ok {
		that2, ok := that.(ArgFetch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Zone != that1.Zone {
		return false
	}
	if this.Env != that1.Env {
		return false
	}
	if this.AppID != that1.AppID {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ArgFetchs) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ArgFetchs)
	if !ok {
		that2, ok := that.(ArgFetchs)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ArgFetchs")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ArgFetchs but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ArgFetchs but is not nil && this == nil")
	}
	if this.Zone != that1.Zone {
		return fmt.Errorf("Zone this(%v) Not Equal that(%v)", this.Zone, that1.Zone)
	}
	if this.Env != that1.Env {
		return fmt.Errorf("Env this(%v) Not Equal that(%v)", this.Env, that1.Env)
	}
	if len(this.AppID) != len(that1.AppID) {
		return fmt.Errorf("AppID this(%v) Not Equal that(%v)", len(this.AppID), len(that1.AppID))
	}
	for i := range this.AppID {
		if this.AppID[i] != that1.AppID[i] {
			return fmt.Errorf("AppID this[%v](%v) Not Equal that[%v](%v)", i, this.AppID[i], i, that1.AppID[i])
		}
	}
	if this.Status != that1.Status {
		return fmt.Errorf("Status this(%v) Not Equal that(%v)", this.Status, that1.Status)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *ArgFetchs) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ArgFetchs)
	if !ok {
		that2, ok := that.(ArgFetchs)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Zone != that1.Zone {
		return false
	}
	if this.Env != that1.Env {
		return false
	}
	if len(this.AppID) != len(that1.AppID) {
		return false
	}
	for i := range this.AppID {
		if this.AppID[i] != that1.AppID[i] {
			return false
		}
	}
	if this.Status != that1.Status {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ArgRoll) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ArgRoll)
	if !ok {
		that2, ok := that.(ArgRoll)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ArgRoll")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ArgRoll but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ArgRoll but is not nil && this == nil")
	}
	if this.Zone != that1.Zone {
		return fmt.Errorf("Zone this(%v) Not Equal that(%v)", this.Zone, that1.Zone)
	}
	if this.Env != that1.Env {
		return fmt.Errorf("Env this(%v) Not Equal that(%v)", this.Env, that1.Env)
	}
	if this.AppID != that1.AppID {
		return fmt.Errorf("AppID this(%v) Not Equal that(%v)", this.AppID, that1.AppID)
	}
	if this.Hostname != that1.Hostname {
		return fmt.Errorf("Hostname this(%v) Not Equal that(%v)", this.Hostname, that1.Hostname)
	}
	if this.LatestTimestamp != that1.LatestTimestamp {
		return fmt.Errorf("LatestTimestamp this(%v) Not Equal that(%v)", this.LatestTimestamp, that1.LatestTimestamp)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *ArgRoll) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ArgRoll)
	if !ok {
		that2, ok := that.(ArgRoll)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Zone != that1.Zone {
		return false
	}
	if this.Env != that1.Env {
		return false
	}
	if this.AppID != that1.AppID {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	if this.LatestTimestamp != that1.LatestTimestamp {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ArgRolls) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ArgRolls)
	if !ok {
		that2, ok := that.(ArgRolls)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ArgRolls")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ArgRolls but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ArgRolls but is not nil && this == nil")
	}
	if this.Zone != that1.Zone {
		return fmt.Errorf("Zone this(%v) Not Equal that(%v)", this.Zone, that1.Zone)
	}
	if this.Env != that1.Env {
		return fmt.Errorf("Env this(%v) Not Equal that(%v)", this.Env, that1.Env)
	}
	if len(this.AppID) != len(that1.AppID) {
		return fmt.Errorf("AppID this(%v) Not Equal that(%v)", len(this.AppID), len(that1.AppID))
	}
	for i := range this.AppID {
		if this.AppID[i] != that1.AppID[i] {
			return fmt.Errorf("AppID this[%v](%v) Not Equal that[%v](%v)", i, this.AppID[i], i, that1.AppID[i])
		}
	}
	if this.Hostname != that1.Hostname {
		return fmt.Errorf("Hostname this(%v) Not Equal that(%v)", this.Hostname, that1.Hostname)
	}
	if len(this.LatestTimestamp) != len(that1.LatestTimestamp) {
		return fmt.Errorf("LatestTimestamp this(%v) Not Equal that(%v)", len(this.LatestTimestamp), len(that1.LatestTimestamp))
	}
	for i := range this.LatestTimestamp {
		if this.LatestTimestamp[i] != that1.LatestTimestamp[i] {
			return fmt.Errorf("LatestTimestamp this[%v](%v) Not Equal that[%v](%v)", i, this.LatestTimestamp[i], i, that1.LatestTimestamp[i])
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *ArgRolls) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ArgRolls)
	if !ok {
		that2, ok := that.(ArgRolls)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Zone != that1.Zone {
		return false
	}
	if this.Env != that1.Env {
		return false
	}
	if len(this.AppID) != len(that1.AppID) {
		return false
	}
	for i := range this.AppID {
		if this.AppID[i] != that1.AppID[i] {
			return false
		}
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	if len(this.LatestTimestamp) != len(that1.LatestTimestamp) {
		return false
	}
	for i := range this.LatestTimestamp {
		if this.LatestTimestamp[i] != that1.LatestTimestamp[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ArqSet) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ArqSet)
	if !ok {
		that2, ok := that.(ArqSet)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ArqSet")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ArqSet but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ArqSet but is not nil && this == nil")
	}
	if this.Zone != that1.Zone {
		return fmt.Errorf("Zone this(%v) Not Equal that(%v)", this.Zone, that1.Zone)
	}
	if this.Env != that1.Env {
		return fmt.Errorf("Env this(%v) Not Equal that(%v)", this.Env, that1.Env)
	}
	if this.AppID != that1.AppID {
		return fmt.Errorf("AppID this(%v) Not Equal that(%v)", this.AppID, that1.AppID)
	}
	if len(this.Hostname) != len(that1.Hostname) {
		return fmt.Errorf("Hostname this(%v) Not Equal that(%v)", len(this.Hostname), len(that1.Hostname))
	}
	for i := range this.Hostname {
		if this.Hostname[i] != that1.Hostname[i] {
			return fmt.Errorf("Hostname this[%v](%v) Not Equal that[%v](%v)", i, this.Hostname[i], i, that1.Hostname[i])
		}
	}
	if len(this.Status) != len(that1.Status) {
		return fmt.Errorf("Status this(%v) Not Equal that(%v)", len(this.Status), len(that1.Status))
	}
	for i := range this.Status {
		if this.Status[i] != that1.Status[i] {
			return fmt.Errorf("Status this[%v](%v) Not Equal that[%v](%v)", i, this.Status[i], i, that1.Status[i])
		}
	}
	if len(this.Metadata) != len(that1.Metadata) {
		return fmt.Errorf("Metadata this(%v) Not Equal that(%v)", len(this.Metadata), len(that1.Metadata))
	}
	for i := range this.Metadata {
		if this.Metadata[i] != that1.Metadata[i] {
			return fmt.Errorf("Metadata this[%v](%v) Not Equal that[%v](%v)", i, this.Metadata[i], i, that1.Metadata[i])
		}
	}
	if this.Replication != that1.Replication {
		return fmt.Errorf("Replication this(%v) Not Equal that(%v)", this.Replication, that1.Replication)
	}
	if this.SetTimestamp != that1.SetTimestamp {
		return fmt.Errorf("SetTimestamp this(%v) Not Equal that(%v)", this.SetTimestamp, that1.SetTimestamp)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *ArqSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ArqSet)
	if !ok {
		that2, ok := that.(ArqSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Zone != that1.Zone {
		return false
	}
	if this.Env != that1.Env {
		return false
	}
	if this.AppID != that1.AppID {
		return false
	}
	if len(this.Hostname) != len(that1.Hostname) {
		return false
	}
	for i := range this.Hostname {
		if this.Hostname[i] != that1.Hostname[i] {
			return false
		}
	}
	if len(this.Status) != len(that1.Status) {
		return false
	}
	for i := range this.Status {
		if this.Status[i] != that1.Status[i] {
			return false
		}
	}
	if len(this.Metadata) != len(that1.Metadata) {
		return false
	}
	for i := range this.Metadata {
		if this.Metadata[i] != that1.Metadata[i] {
			return false
		}
	}
	if this.Replication != that1.Replication {
		return false
	}
	if this.SetTimestamp != that1.SetTimestamp {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RespMsg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&eureka.RespMsg{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Msg: "+fmt.Sprintf("%#v", this.Msg)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Zone) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&eureka.Zone{")
	s = append(s, "Src: "+fmt.Sprintf("%#v", this.Src)+",\n")
	keysForDst := make([]string, 0, len(this.Dst))
	for k, _ := range this.Dst {
		keysForDst = append(keysForDst, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForDst)
	mapStringForDst := "map[string]uint32{"
	for _, k := range keysForDst {
		mapStringForDst += fmt.Sprintf("%#v: %#v,", k, this.Dst[k])
	}
	mapStringForDst += "}"
	if this.Dst != nil {
		s = append(s, "Dst: "+mapStringForDst+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Node) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&eureka.Node{")
	s = append(s, "Addr: "+fmt.Sprintf("%#v", this.Addr)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Zone: "+fmt.Sprintf("%#v", this.Zone)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RespNodes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&eureka.RespNodes{")
	if this.Notes != nil {
		s = append(s, "Notes: "+fmt.Sprintf("%#v", this.Notes)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Instance) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&eureka.Instance{")
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	s = append(s, "Zone: "+fmt.Sprintf("%#v", this.Zone)+",\n")
	s = append(s, "Env: "+fmt.Sprintf("%#v", this.Env)+",\n")
	s = append(s, "AppID: "+fmt.Sprintf("%#v", this.AppID)+",\n")
	s = append(s, "Hostname: "+fmt.Sprintf("%#v", this.Hostname)+",\n")
	s = append(s, "Addrs: "+fmt.Sprintf("%#v", this.Addrs)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	keysForMetadata := make([]string, 0, len(this.Metadata))
	for k, _ := range this.Metadata {
		keysForMetadata = append(keysForMetadata, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMetadata)
	mapStringForMetadata := "map[string]string{"
	for _, k := range keysForMetadata {
		mapStringForMetadata += fmt.Sprintf("%#v: %#v,", k, this.Metadata[k])
	}
	mapStringForMetadata += "}"
	if this.Metadata != nil {
		s = append(s, "Metadata: "+mapStringForMetadata+",\n")
	}
	s = append(s, "RegTimestamp: "+fmt.Sprintf("%#v", this.RegTimestamp)+",\n")
	s = append(s, "UpTimestamp: "+fmt.Sprintf("%#v", this.UpTimestamp)+",\n")
	s = append(s, "RenewTimestamp: "+fmt.Sprintf("%#v", this.RenewTimestamp)+",\n")
	s = append(s, "DirtyTimestamp: "+fmt.Sprintf("%#v", this.DirtyTimestamp)+",\n")
	s = append(s, "LatestTimestamp: "+fmt.Sprintf("%#v", this.LatestTimestamp)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *App) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&eureka.App{")
	s = append(s, "AppID: "+fmt.Sprintf("%#v", this.AppID)+",\n")
	s = append(s, "Zone: "+fmt.Sprintf("%#v", this.Zone)+",\n")
	keysForInstances := make([]string, 0, len(this.Instances))
	for k, _ := range this.Instances {
		keysForInstances = append(keysForInstances, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForInstances)
	mapStringForInstances := "map[string]*Instance{"
	for _, k := range keysForInstances {
		mapStringForInstances += fmt.Sprintf("%#v: %#v,", k, this.Instances[k])
	}
	mapStringForInstances += "}"
	if this.Instances != nil {
		s = append(s, "Instances: "+mapStringForInstances+",\n")
	}
	s = append(s, "LatestTimestamp: "+fmt.Sprintf("%#v", this.LatestTimestamp)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Apps) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&eureka.Apps{")
	keysForApps := make([]string, 0, len(this.Apps))
	for k, _ := range this.Apps {
		keysForApps = append(keysForApps, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForApps)
	mapStringForApps := "map[string]*App{"
	for _, k := range keysForApps {
		mapStringForApps += fmt.Sprintf("%#v: %#v,", k, this.Apps[k])
	}
	mapStringForApps += "}"
	if this.Apps != nil {
		s = append(s, "Apps: "+mapStringForApps+",\n")
	}
	s = append(s, "LatestTimestamp: "+fmt.Sprintf("%#v", this.LatestTimestamp)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Instances) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&eureka.Instances{")
	if this.Instances != nil {
		s = append(s, "Instances: "+fmt.Sprintf("%#v", this.Instances)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InstanceInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&eureka.InstanceInfo{")
	keysForInstance := make([]string, 0, len(this.Instance))
	for k, _ := range this.Instance {
		keysForInstance = append(keysForInstance, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForInstance)
	mapStringForInstance := "map[string]*Instances{"
	for _, k := range keysForInstance {
		mapStringForInstance += fmt.Sprintf("%#v: %#v,", k, this.Instance[k])
	}
	mapStringForInstance += "}"
	if this.Instance != nil {
		s = append(s, "Instance: "+mapStringForInstance+",\n")
	}
	if this.Scheduler != nil {
		s = append(s, "Scheduler: "+fmt.Sprintf("%#v", this.Scheduler)+",\n")
	}
	s = append(s, "LatestTimestamp: "+fmt.Sprintf("%#v", this.LatestTimestamp)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RespFech) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&eureka.RespFech{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	if this.Data != nil {
		s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	}
	s = append(s, "LatestTimestamp: "+fmt.Sprintf("%#v", this.LatestTimestamp)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RespFechs) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&eureka.RespFechs{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	keysForData := make([]string, 0, len(this.Data))
	for k, _ := range this.Data {
		keysForData = append(keysForData, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForData)
	mapStringForData := "map[string]*InstanceInfo{"
	for _, k := range keysForData {
		mapStringForData += fmt.Sprintf("%#v: %#v,", k, this.Data[k])
	}
	mapStringForData += "}"
	if this.Data != nil {
		s = append(s, "Data: "+mapStringForData+",\n")
	}
	s = append(s, "LatestTimestamp: "+fmt.Sprintf("%#v", this.LatestTimestamp)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RespNodes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&eureka.RespNodes{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	keysForData := make([]string, 0, len(this.Data))
	for k, _ := range this.Data {
		keysForData = append(keysForData, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForData)
	mapStringForData := "map[string]*Node{"
	for _, k := range keysForData {
		mapStringForData += fmt.Sprintf("%#v: %#v,", k, this.Data[k])
	}
	mapStringForData += "}"
	if this.Data != nil {
		s = append(s, "Data: "+mapStringForData+",\n")
	}
	s = append(s, "LatestTimestamp: "+fmt.Sprintf("%#v", this.LatestTimestamp)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ArgRegister) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&eureka.ArgRegister{")
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	s = append(s, "Zone: "+fmt.Sprintf("%#v", this.Zone)+",\n")
	s = append(s, "Env: "+fmt.Sprintf("%#v", this.Env)+",\n")
	s = append(s, "AppID: "+fmt.Sprintf("%#v", this.AppID)+",\n")
	s = append(s, "Hostname: "+fmt.Sprintf("%#v", this.Hostname)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Addrs: "+fmt.Sprintf("%#v", this.Addrs)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	s = append(s, "Replication: "+fmt.Sprintf("%#v", this.Replication)+",\n")
	s = append(s, "LatestTimestamp: "+fmt.Sprintf("%#v", this.LatestTimestamp)+",\n")
	s = append(s, "DirtyTimestamp: "+fmt.Sprintf("%#v", this.DirtyTimestamp)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ArgRenew) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&eureka.ArgRenew{")
	s = append(s, "Zone: "+fmt.Sprintf("%#v", this.Zone)+",\n")
	s = append(s, "Env: "+fmt.Sprintf("%#v", this.Env)+",\n")
	s = append(s, "AppID: "+fmt.Sprintf("%#v", this.AppID)+",\n")
	s = append(s, "Hostname: "+fmt.Sprintf("%#v", this.Hostname)+",\n")
	s = append(s, "Replication: "+fmt.Sprintf("%#v", this.Replication)+",\n")
	s = append(s, "DirtyTimestamp: "+fmt.Sprintf("%#v", this.DirtyTimestamp)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ArgCancel) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&eureka.ArgCancel{")
	s = append(s, "Zone: "+fmt.Sprintf("%#v", this.Zone)+",\n")
	s = append(s, "Env: "+fmt.Sprintf("%#v", this.Env)+",\n")
	s = append(s, "AppID: "+fmt.Sprintf("%#v", this.AppID)+",\n")
	s = append(s, "Hostname: "+fmt.Sprintf("%#v", this.Hostname)+",\n")
	s = append(s, "Replication: "+fmt.Sprintf("%#v", this.Replication)+",\n")
	s = append(s, "LatestTimestamp: "+fmt.Sprintf("%#v", this.LatestTimestamp)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ArgFetch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&eureka.ArgFetch{")
	s = append(s, "Zone: "+fmt.Sprintf("%#v", this.Zone)+",\n")
	s = append(s, "Env: "+fmt.Sprintf("%#v", this.Env)+",\n")
	s = append(s, "AppID: "+fmt.Sprintf("%#v", this.AppID)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ArgFetchs) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&eureka.ArgFetchs{")
	s = append(s, "Zone: "+fmt.Sprintf("%#v", this.Zone)+",\n")
	s = append(s, "Env: "+fmt.Sprintf("%#v", this.Env)+",\n")
	s = append(s, "AppID: "+fmt.Sprintf("%#v", this.AppID)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ArgRoll) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&eureka.ArgRoll{")
	s = append(s, "Zone: "+fmt.Sprintf("%#v", this.Zone)+",\n")
	s = append(s, "Env: "+fmt.Sprintf("%#v", this.Env)+",\n")
	s = append(s, "AppID: "+fmt.Sprintf("%#v", this.AppID)+",\n")
	s = append(s, "Hostname: "+fmt.Sprintf("%#v", this.Hostname)+",\n")
	s = append(s, "LatestTimestamp: "+fmt.Sprintf("%#v", this.LatestTimestamp)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ArgRolls) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&eureka.ArgRolls{")
	s = append(s, "Zone: "+fmt.Sprintf("%#v", this.Zone)+",\n")
	s = append(s, "Env: "+fmt.Sprintf("%#v", this.Env)+",\n")
	s = append(s, "AppID: "+fmt.Sprintf("%#v", this.AppID)+",\n")
	s = append(s, "Hostname: "+fmt.Sprintf("%#v", this.Hostname)+",\n")
	s = append(s, "LatestTimestamp: "+fmt.Sprintf("%#v", this.LatestTimestamp)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ArqSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&eureka.ArqSet{")
	s = append(s, "Zone: "+fmt.Sprintf("%#v", this.Zone)+",\n")
	s = append(s, "Env: "+fmt.Sprintf("%#v", this.Env)+",\n")
	s = append(s, "AppID: "+fmt.Sprintf("%#v", this.AppID)+",\n")
	s = append(s, "Hostname: "+fmt.Sprintf("%#v", this.Hostname)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	s = append(s, "Replication: "+fmt.Sprintf("%#v", this.Replication)+",\n")
	s = append(s, "SetTimestamp: "+fmt.Sprintf("%#v", this.SetTimestamp)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringDiscovery(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// EurekaDiscoveryClient is the client API for EurekaDiscovery service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EurekaDiscoveryClient interface {
	Register(ctx context.Context, in *ArgRegister, opts ...grpc.CallOption) (*RespMsg, error)
	Renew(ctx context.Context, in *ArgRenew, opts ...grpc.CallOption) (*RespMsg, error)
	Cancel(ctx context.Context, in *ArgCancel, opts ...grpc.CallOption) (*RespMsg, error)
	Fetch(ctx context.Context, in *ArgFetch, opts ...grpc.CallOption) (*RespFech, error)
	FetchAll(ctx context.Context, in *ArgFetchs, opts ...grpc.CallOption) (*RespFechs, error)
	Poll(ctx context.Context, in *ArgFetch, opts ...grpc.CallOption) (EurekaDiscovery_PollClient, error)
	Polls(ctx context.Context, in *ArgFetch, opts ...grpc.CallOption) (EurekaDiscovery_PollsClient, error)
	Nodes(ctx context.Context, in *ArgFetch, opts ...grpc.CallOption) (*RespMsg, error)
	Set(ctx context.Context, in *ArqSet, opts ...grpc.CallOption) (*RespMsg, error)
}

type eurekaDiscoveryClient struct {
	cc *grpc.ClientConn
}

func NewEurekaDiscoveryClient(cc *grpc.ClientConn) EurekaDiscoveryClient {
	return &eurekaDiscoveryClient{cc}
}

func (c *eurekaDiscoveryClient) Register(ctx context.Context, in *ArgRegister, opts ...grpc.CallOption) (*RespMsg, error) {
	out := new(RespMsg)
	err := c.cc.Invoke(ctx, "/gopkg.in.srcd.proteus.v1.example.EurekaDiscovery/Register", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eurekaDiscoveryClient) Renew(ctx context.Context, in *ArgRenew, opts ...grpc.CallOption) (*RespMsg, error) {
	out := new(RespMsg)
	err := c.cc.Invoke(ctx, "/gopkg.in.srcd.proteus.v1.example.EurekaDiscovery/Renew", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eurekaDiscoveryClient) Cancel(ctx context.Context, in *ArgCancel, opts ...grpc.CallOption) (*RespMsg, error) {
	out := new(RespMsg)
	err := c.cc.Invoke(ctx, "/gopkg.in.srcd.proteus.v1.example.EurekaDiscovery/Cancel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eurekaDiscoveryClient) Fetch(ctx context.Context, in *ArgFetch, opts ...grpc.CallOption) (*RespFech, error) {
	out := new(RespFech)
	err := c.cc.Invoke(ctx, "/gopkg.in.srcd.proteus.v1.example.EurekaDiscovery/Fetch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eurekaDiscoveryClient) FetchAll(ctx context.Context, in *ArgFetchs, opts ...grpc.CallOption) (*RespFechs, error) {
	out := new(RespFechs)
	err := c.cc.Invoke(ctx, "/gopkg.in.srcd.proteus.v1.example.EurekaDiscovery/FetchAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eurekaDiscoveryClient) Poll(ctx context.Context, in *ArgFetch, opts ...grpc.CallOption) (EurekaDiscovery_PollClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EurekaDiscovery_serviceDesc.Streams[0], "/gopkg.in.srcd.proteus.v1.example.EurekaDiscovery/Poll", opts...)
	if err != nil {
		return nil, err
	}
	x := &eurekaDiscoveryPollClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EurekaDiscovery_PollClient interface {
	Recv() (*RespFech, error)
	grpc.ClientStream
}

type eurekaDiscoveryPollClient struct {
	grpc.ClientStream
}

func (x *eurekaDiscoveryPollClient) Recv() (*RespFech, error) {
	m := new(RespFech)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *eurekaDiscoveryClient) Polls(ctx context.Context, in *ArgFetch, opts ...grpc.CallOption) (EurekaDiscovery_PollsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EurekaDiscovery_serviceDesc.Streams[1], "/gopkg.in.srcd.proteus.v1.example.EurekaDiscovery/Polls", opts...)
	if err != nil {
		return nil, err
	}
	x := &eurekaDiscoveryPollsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EurekaDiscovery_PollsClient interface {
	Recv() (*RespFechs, error)
	grpc.ClientStream
}

type eurekaDiscoveryPollsClient struct {
	grpc.ClientStream
}

func (x *eurekaDiscoveryPollsClient) Recv() (*RespFechs, error) {
	m := new(RespFechs)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *eurekaDiscoveryClient) Nodes(ctx context.Context, in *ArgFetch, opts ...grpc.CallOption) (*RespMsg, error) {
	out := new(RespMsg)
	err := c.cc.Invoke(ctx, "/gopkg.in.srcd.proteus.v1.example.EurekaDiscovery/Nodes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eurekaDiscoveryClient) Set(ctx context.Context, in *ArqSet, opts ...grpc.CallOption) (*RespMsg, error) {
	out := new(RespMsg)
	err := c.cc.Invoke(ctx, "/gopkg.in.srcd.proteus.v1.example.EurekaDiscovery/Set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EurekaDiscoveryServer is the server API for EurekaDiscovery service.
type EurekaDiscoveryServer interface {
	Register(context.Context, *ArgRegister) (*RespMsg, error)
	Renew(context.Context, *ArgRenew) (*RespMsg, error)
	Cancel(context.Context, *ArgCancel) (*RespMsg, error)
	Fetch(context.Context, *ArgFetch) (*RespFech, error)
	FetchAll(context.Context, *ArgFetchs) (*RespFechs, error)
	Poll(*ArgFetch, EurekaDiscovery_PollServer) error
	Polls(*ArgFetch, EurekaDiscovery_PollsServer) error
	Nodes(context.Context, *ArgFetch) (*RespMsg, error)
	Set(context.Context, *ArqSet) (*RespMsg, error)
}

func RegisterEurekaDiscoveryServer(s *grpc.Server, srv EurekaDiscoveryServer) {
	s.RegisterService(&_EurekaDiscovery_serviceDesc, srv)
}

func _EurekaDiscovery_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArgRegister)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EurekaDiscoveryServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gopkg.in.srcd.proteus.v1.example.EurekaDiscovery/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EurekaDiscoveryServer).Register(ctx, req.(*ArgRegister))
	}
	return interceptor(ctx, in, info, handler)
}

func _EurekaDiscovery_Renew_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArgRenew)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EurekaDiscoveryServer).Renew(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gopkg.in.srcd.proteus.v1.example.EurekaDiscovery/Renew",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EurekaDiscoveryServer).Renew(ctx, req.(*ArgRenew))
	}
	return interceptor(ctx, in, info, handler)
}

func _EurekaDiscovery_Cancel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArgCancel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EurekaDiscoveryServer).Cancel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gopkg.in.srcd.proteus.v1.example.EurekaDiscovery/Cancel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EurekaDiscoveryServer).Cancel(ctx, req.(*ArgCancel))
	}
	return interceptor(ctx, in, info, handler)
}

func _EurekaDiscovery_Fetch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArgFetch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EurekaDiscoveryServer).Fetch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gopkg.in.srcd.proteus.v1.example.EurekaDiscovery/Fetch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EurekaDiscoveryServer).Fetch(ctx, req.(*ArgFetch))
	}
	return interceptor(ctx, in, info, handler)
}

func _EurekaDiscovery_FetchAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArgFetchs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EurekaDiscoveryServer).FetchAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gopkg.in.srcd.proteus.v1.example.EurekaDiscovery/FetchAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EurekaDiscoveryServer).FetchAll(ctx, req.(*ArgFetchs))
	}
	return interceptor(ctx, in, info, handler)
}

func _EurekaDiscovery_Poll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ArgFetch)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EurekaDiscoveryServer).Poll(m, &eurekaDiscoveryPollServer{stream})
}

type EurekaDiscovery_PollServer interface {
	Send(*RespFech) error
	grpc.ServerStream
}

type eurekaDiscoveryPollServer struct {
	grpc.ServerStream
}

func (x *eurekaDiscoveryPollServer) Send(m *RespFech) error {
	return x.ServerStream.SendMsg(m)
}

func _EurekaDiscovery_Polls_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ArgFetch)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EurekaDiscoveryServer).Polls(m, &eurekaDiscoveryPollsServer{stream})
}

type EurekaDiscovery_PollsServer interface {
	Send(*RespFechs) error
	grpc.ServerStream
}

type eurekaDiscoveryPollsServer struct {
	grpc.ServerStream
}

func (x *eurekaDiscoveryPollsServer) Send(m *RespFechs) error {
	return x.ServerStream.SendMsg(m)
}

func _EurekaDiscovery_Nodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArgFetch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EurekaDiscoveryServer).Nodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gopkg.in.srcd.proteus.v1.example.EurekaDiscovery/Nodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EurekaDiscoveryServer).Nodes(ctx, req.(*ArgFetch))
	}
	return interceptor(ctx, in, info, handler)
}

func _EurekaDiscovery_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArqSet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EurekaDiscoveryServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gopkg.in.srcd.proteus.v1.example.EurekaDiscovery/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EurekaDiscoveryServer).Set(ctx, req.(*ArqSet))
	}
	return interceptor(ctx, in, info, handler)
}

var _EurekaDiscovery_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gopkg.in.srcd.proteus.v1.example.EurekaDiscovery",
	HandlerType: (*EurekaDiscoveryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _EurekaDiscovery_Register_Handler,
		},
		{
			MethodName: "Renew",
			Handler:    _EurekaDiscovery_Renew_Handler,
		},
		{
			MethodName: "Cancel",
			Handler:    _EurekaDiscovery_Cancel_Handler,
		},
		{
			MethodName: "Fetch",
			Handler:    _EurekaDiscovery_Fetch_Handler,
		},
		{
			MethodName: "FetchAll",
			Handler:    _EurekaDiscovery_FetchAll_Handler,
		},
		{
			MethodName: "Nodes",
			Handler:    _EurekaDiscovery_Nodes_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _EurekaDiscovery_Set_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Poll",
			Handler:       _EurekaDiscovery_Poll_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Polls",
			Handler:       _EurekaDiscovery_Polls_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "discovery.proto",
}

func (m *RespMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RespMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Zone) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Zone) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Src) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Src)))
		i += copy(dAtA[i:], m.Src)
	}
	if len(m.Dst) > 0 {
		for k, _ := range m.Dst {
			dAtA[i] = 0x12
			i++
			v := m.Dst[k]
			mapSize := 1 + len(k) + sovDiscovery(uint64(len(k))) + 1 + sovDiscovery(uint64(v))
			i = encodeVarintDiscovery(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintDiscovery(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintDiscovery(dAtA, i, uint64(v))
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Addr)))
		i += copy(dAtA[i:], m.Addr)
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(m.Status))
	}
	if len(m.Zone) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Zone)))
		i += copy(dAtA[i:], m.Zone)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RespNodes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RespNodes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Notes) > 0 {
		for _, msg := range m.Notes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDiscovery(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Instance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Instance) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Region) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Region)))
		i += copy(dAtA[i:], m.Region)
	}
	if len(m.Zone) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Zone)))
		i += copy(dAtA[i:], m.Zone)
	}
	if len(m.Env) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Env)))
		i += copy(dAtA[i:], m.Env)
	}
	if len(m.AppID) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.AppID)))
		i += copy(dAtA[i:], m.AppID)
	}
	if len(m.Hostname) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Hostname)))
		i += copy(dAtA[i:], m.Hostname)
	}
	if len(m.Addrs) > 0 {
		for _, s := range m.Addrs {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Status != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(m.Status))
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.Metadata) > 0 {
		for k, _ := range m.Metadata {
			dAtA[i] = 0x4a
			i++
			v := m.Metadata[k]
			mapSize := 1 + len(k) + sovDiscovery(uint64(len(k))) + 1 + len(v) + sovDiscovery(uint64(len(v)))
			i = encodeVarintDiscovery(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintDiscovery(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintDiscovery(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.RegTimestamp != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(m.RegTimestamp))
	}
	if m.UpTimestamp != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(m.UpTimestamp))
	}
	if m.RenewTimestamp != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(m.RenewTimestamp))
	}
	if m.DirtyTimestamp != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(m.DirtyTimestamp))
	}
	if m.LatestTimestamp != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(m.LatestTimestamp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *App) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *App) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.AppID)))
		i += copy(dAtA[i:], m.AppID)
	}
	if len(m.Zone) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Zone)))
		i += copy(dAtA[i:], m.Zone)
	}
	if len(m.Instances) > 0 {
		for k, _ := range m.Instances {
			dAtA[i] = 0x1a
			i++
			v := m.Instances[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovDiscovery(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovDiscovery(uint64(len(k))) + msgSize
			i = encodeVarintDiscovery(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintDiscovery(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintDiscovery(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	if m.LatestTimestamp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(m.LatestTimestamp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Apps) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Apps) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Apps) > 0 {
		for k, _ := range m.Apps {
			dAtA[i] = 0xa
			i++
			v := m.Apps[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovDiscovery(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovDiscovery(uint64(len(k))) + msgSize
			i = encodeVarintDiscovery(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintDiscovery(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintDiscovery(dAtA, i, uint64(v.Size()))
				n2, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n2
			}
		}
	}
	if m.LatestTimestamp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(m.LatestTimestamp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Instances) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Instances) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Instances) > 0 {
		for _, msg := range m.Instances {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDiscovery(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InstanceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Instance) > 0 {
		for k, _ := range m.Instance {
			dAtA[i] = 0xa
			i++
			v := m.Instance[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovDiscovery(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovDiscovery(uint64(len(k))) + msgSize
			i = encodeVarintDiscovery(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintDiscovery(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintDiscovery(dAtA, i, uint64(v.Size()))
				n3, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	if len(m.Scheduler) > 0 {
		for _, msg := range m.Scheduler {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDiscovery(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LatestTimestamp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(m.LatestTimestamp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RespFech) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RespFech) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Code))))
		i += 8
	}
	if m.Data != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(m.Data.Size()))
		n4, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.LatestTimestamp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(m.LatestTimestamp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RespFechs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RespFechs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Code))))
		i += 8
	}
	if len(m.Data) > 0 {
		for k, _ := range m.Data {
			dAtA[i] = 0x12
			i++
			v := m.Data[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovDiscovery(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovDiscovery(uint64(len(k))) + msgSize
			i = encodeVarintDiscovery(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintDiscovery(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintDiscovery(dAtA, i, uint64(v.Size()))
				n5, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n5
			}
		}
	}
	if m.LatestTimestamp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(m.LatestTimestamp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RespNodes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RespNodes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Code))))
		i += 8
	}
	if len(m.Data) > 0 {
		for k, _ := range m.Data {
			dAtA[i] = 0x12
			i++
			v := m.Data[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovDiscovery(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovDiscovery(uint64(len(k))) + msgSize
			i = encodeVarintDiscovery(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintDiscovery(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintDiscovery(dAtA, i, uint64(v.Size()))
				n6, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n6
			}
		}
	}
	if m.LatestTimestamp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(m.LatestTimestamp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ArgRegister) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgRegister) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Region) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Region)))
		i += copy(dAtA[i:], m.Region)
	}
	if len(m.Zone) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Zone)))
		i += copy(dAtA[i:], m.Zone)
	}
	if len(m.Env) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Env)))
		i += copy(dAtA[i:], m.Env)
	}
	if len(m.AppID) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.AppID)))
		i += copy(dAtA[i:], m.AppID)
	}
	if len(m.Hostname) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Hostname)))
		i += copy(dAtA[i:], m.Hostname)
	}
	if m.Status != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(m.Status))
	}
	if len(m.Addrs) > 0 {
		for _, s := range m.Addrs {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.Metadata) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Metadata)))
		i += copy(dAtA[i:], m.Metadata)
	}
	if m.Replication {
		dAtA[i] = 0x50
		i++
		if m.Replication {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LatestTimestamp != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(m.LatestTimestamp))
	}
	if m.DirtyTimestamp != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(m.DirtyTimestamp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ArgRenew) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgRenew) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Zone) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Zone)))
		i += copy(dAtA[i:], m.Zone)
	}
	if len(m.Env) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Env)))
		i += copy(dAtA[i:], m.Env)
	}
	if len(m.AppID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.AppID)))
		i += copy(dAtA[i:], m.AppID)
	}
	if len(m.Hostname) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Hostname)))
		i += copy(dAtA[i:], m.Hostname)
	}
	if m.Replication {
		dAtA[i] = 0x28
		i++
		if m.Replication {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DirtyTimestamp != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(m.DirtyTimestamp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ArgCancel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgCancel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Zone) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Zone)))
		i += copy(dAtA[i:], m.Zone)
	}
	if len(m.Env) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Env)))
		i += copy(dAtA[i:], m.Env)
	}
	if len(m.AppID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.AppID)))
		i += copy(dAtA[i:], m.AppID)
	}
	if len(m.Hostname) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Hostname)))
		i += copy(dAtA[i:], m.Hostname)
	}
	if m.Replication {
		dAtA[i] = 0x28
		i++
		if m.Replication {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LatestTimestamp != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(m.LatestTimestamp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ArgFetch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgFetch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Zone) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Zone)))
		i += copy(dAtA[i:], m.Zone)
	}
	if len(m.Env) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Env)))
		i += copy(dAtA[i:], m.Env)
	}
	if len(m.AppID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.AppID)))
		i += copy(dAtA[i:], m.AppID)
	}
	if m.Status != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ArgFetchs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgFetchs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Zone) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Zone)))
		i += copy(dAtA[i:], m.Zone)
	}
	if len(m.Env) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Env)))
		i += copy(dAtA[i:], m.Env)
	}
	if len(m.AppID) > 0 {
		for _, s := range m.AppID {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Status != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ArgRoll) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgRoll) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Zone) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Zone)))
		i += copy(dAtA[i:], m.Zone)
	}
	if len(m.Env) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Env)))
		i += copy(dAtA[i:], m.Env)
	}
	if len(m.AppID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.AppID)))
		i += copy(dAtA[i:], m.AppID)
	}
	if len(m.Hostname) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Hostname)))
		i += copy(dAtA[i:], m.Hostname)
	}
	if m.LatestTimestamp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(m.LatestTimestamp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ArgRolls) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArgRolls) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Zone) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Zone)))
		i += copy(dAtA[i:], m.Zone)
	}
	if len(m.Env) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Env)))
		i += copy(dAtA[i:], m.Env)
	}
	if len(m.AppID) > 0 {
		for _, s := range m.AppID {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Hostname) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Hostname)))
		i += copy(dAtA[i:], m.Hostname)
	}
	if len(m.LatestTimestamp) > 0 {
		dAtA8 := make([]byte, len(m.LatestTimestamp)*10)
		var j7 int
		for _, num1 := range m.LatestTimestamp {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ArqSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArqSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Zone) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Zone)))
		i += copy(dAtA[i:], m.Zone)
	}
	if len(m.Env) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Env)))
		i += copy(dAtA[i:], m.Env)
	}
	if len(m.AppID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.AppID)))
		i += copy(dAtA[i:], m.AppID)
	}
	if len(m.Hostname) > 0 {
		for _, s := range m.Hostname {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDiscovery(dAtA, i, uint64(len(m.Status)*4))
		for _, num := range m.Status {
			f9 := math.Float32bits(float32(num))
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f9))
			i += 4
		}
	}
	if len(m.Metadata) > 0 {
		for _, s := range m.Metadata {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Replication {
		dAtA[i] = 0x38
		i++
		if m.Replication {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SetTimestamp != 0 {
		dAtA[i] = 0x41
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.SetTimestamp))))
		i += 8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintDiscovery(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RespMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovDiscovery(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Zone) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Src)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	if len(m.Dst) > 0 {
		for k, v := range m.Dst {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovDiscovery(uint64(len(k))) + 1 + sovDiscovery(uint64(v))
			n += mapEntrySize + 1 + sovDiscovery(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovDiscovery(uint64(m.Status))
	}
	l = len(m.Zone)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RespNodes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Notes) > 0 {
		for _, e := range m.Notes {
			l = e.Size()
			n += 1 + l + sovDiscovery(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Instance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	l = len(m.Zone)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	l = len(m.Env)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	if len(m.Addrs) > 0 {
		for _, s := range m.Addrs {
			l = len(s)
			n += 1 + l + sovDiscovery(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovDiscovery(uint64(m.Status))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovDiscovery(uint64(len(k))) + 1 + len(v) + sovDiscovery(uint64(len(v)))
			n += mapEntrySize + 1 + sovDiscovery(uint64(mapEntrySize))
		}
	}
	if m.RegTimestamp != 0 {
		n += 1 + sovDiscovery(uint64(m.RegTimestamp))
	}
	if m.UpTimestamp != 0 {
		n += 1 + sovDiscovery(uint64(m.UpTimestamp))
	}
	if m.RenewTimestamp != 0 {
		n += 1 + sovDiscovery(uint64(m.RenewTimestamp))
	}
	if m.DirtyTimestamp != 0 {
		n += 1 + sovDiscovery(uint64(m.DirtyTimestamp))
	}
	if m.LatestTimestamp != 0 {
		n += 1 + sovDiscovery(uint64(m.LatestTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *App) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	l = len(m.Zone)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	if len(m.Instances) > 0 {
		for k, v := range m.Instances {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovDiscovery(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovDiscovery(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovDiscovery(uint64(mapEntrySize))
		}
	}
	if m.LatestTimestamp != 0 {
		n += 1 + sovDiscovery(uint64(m.LatestTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Apps) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Apps) > 0 {
		for k, v := range m.Apps {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovDiscovery(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovDiscovery(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovDiscovery(uint64(mapEntrySize))
		}
	}
	if m.LatestTimestamp != 0 {
		n += 1 + sovDiscovery(uint64(m.LatestTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Instances) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Instances) > 0 {
		for _, e := range m.Instances {
			l = e.Size()
			n += 1 + l + sovDiscovery(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InstanceInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Instance) > 0 {
		for k, v := range m.Instance {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovDiscovery(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovDiscovery(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovDiscovery(uint64(mapEntrySize))
		}
	}
	if len(m.Scheduler) > 0 {
		for _, e := range m.Scheduler {
			l = e.Size()
			n += 1 + l + sovDiscovery(uint64(l))
		}
	}
	if m.LatestTimestamp != 0 {
		n += 1 + sovDiscovery(uint64(m.LatestTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RespFech) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 9
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovDiscovery(uint64(l))
	}
	if m.LatestTimestamp != 0 {
		n += 1 + sovDiscovery(uint64(m.LatestTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RespFechs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 9
	}
	if len(m.Data) > 0 {
		for k, v := range m.Data {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovDiscovery(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovDiscovery(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovDiscovery(uint64(mapEntrySize))
		}
	}
	if m.LatestTimestamp != 0 {
		n += 1 + sovDiscovery(uint64(m.LatestTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RespNodes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 9
	}
	if len(m.Data) > 0 {
		for k, v := range m.Data {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovDiscovery(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovDiscovery(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovDiscovery(uint64(mapEntrySize))
		}
	}
	if m.LatestTimestamp != 0 {
		n += 1 + sovDiscovery(uint64(m.LatestTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArgRegister) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	l = len(m.Zone)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	l = len(m.Env)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovDiscovery(uint64(m.Status))
	}
	if len(m.Addrs) > 0 {
		for _, s := range m.Addrs {
			l = len(s)
			n += 1 + l + sovDiscovery(uint64(l))
		}
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	if m.Replication {
		n += 2
	}
	if m.LatestTimestamp != 0 {
		n += 1 + sovDiscovery(uint64(m.LatestTimestamp))
	}
	if m.DirtyTimestamp != 0 {
		n += 1 + sovDiscovery(uint64(m.DirtyTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArgRenew) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Zone)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	l = len(m.Env)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	if m.Replication {
		n += 2
	}
	if m.DirtyTimestamp != 0 {
		n += 1 + sovDiscovery(uint64(m.DirtyTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArgCancel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Zone)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	l = len(m.Env)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	if m.Replication {
		n += 2
	}
	if m.LatestTimestamp != 0 {
		n += 1 + sovDiscovery(uint64(m.LatestTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArgFetch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Zone)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	l = len(m.Env)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovDiscovery(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArgFetchs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Zone)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	l = len(m.Env)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	if len(m.AppID) > 0 {
		for _, s := range m.AppID {
			l = len(s)
			n += 1 + l + sovDiscovery(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovDiscovery(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArgRoll) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Zone)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	l = len(m.Env)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	if m.LatestTimestamp != 0 {
		n += 1 + sovDiscovery(uint64(m.LatestTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArgRolls) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Zone)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	l = len(m.Env)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	if len(m.AppID) > 0 {
		for _, s := range m.AppID {
			l = len(s)
			n += 1 + l + sovDiscovery(uint64(l))
		}
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	if len(m.LatestTimestamp) > 0 {
		l = 0
		for _, e := range m.LatestTimestamp {
			l += sovDiscovery(uint64(e))
		}
		n += 1 + sovDiscovery(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ArqSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Zone)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	l = len(m.Env)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovDiscovery(uint64(l))
	}
	if len(m.Hostname) > 0 {
		for _, s := range m.Hostname {
			l = len(s)
			n += 1 + l + sovDiscovery(uint64(l))
		}
	}
	if len(m.Status) > 0 {
		n += 1 + sovDiscovery(uint64(len(m.Status)*4)) + len(m.Status)*4
	}
	if len(m.Metadata) > 0 {
		for _, s := range m.Metadata {
			l = len(s)
			n += 1 + l + sovDiscovery(uint64(l))
		}
	}
	if m.Replication {
		n += 2
	}
	if m.SetTimestamp != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDiscovery(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDiscovery(x uint64) (n int) {
	return sovDiscovery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RespMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiscovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RespMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RespMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDiscovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Zone) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiscovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Zone: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Zone: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Src = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dst", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dst == nil {
				m.Dst = make(map[string]uint32)
			}
			var mapkey string
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDiscovery
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDiscovery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDiscovery
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDiscovery
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDiscovery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDiscovery(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthDiscovery
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Dst[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDiscovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiscovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDiscovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RespNodes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiscovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: respNodes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: respNodes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notes = append(m.Notes, &Node{})
			if err := m.Notes[len(m.Notes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDiscovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Instance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiscovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Instance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Instance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addrs = append(m.Addrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDiscovery
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDiscovery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDiscovery
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDiscovery
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDiscovery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthDiscovery
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthDiscovery
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDiscovery(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthDiscovery
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegTimestamp", wireType)
			}
			m.RegTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpTimestamp", wireType)
			}
			m.UpTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenewTimestamp", wireType)
			}
			m.RenewTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RenewTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirtyTimestamp", wireType)
			}
			m.DirtyTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DirtyTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestTimestamp", wireType)
			}
			m.LatestTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDiscovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *App) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiscovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: App: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: App: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Instances == nil {
				m.Instances = make(map[string]*Instance)
			}
			var mapkey string
			var mapvalue *Instance
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDiscovery
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDiscovery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDiscovery
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDiscovery
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDiscovery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthDiscovery
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthDiscovery
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Instance{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDiscovery(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthDiscovery
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Instances[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestTimestamp", wireType)
			}
			m.LatestTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDiscovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Apps) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiscovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Apps: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Apps: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Apps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Apps == nil {
				m.Apps = make(map[string]*App)
			}
			var mapkey string
			var mapvalue *App
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDiscovery
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDiscovery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDiscovery
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDiscovery
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDiscovery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthDiscovery
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthDiscovery
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &App{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDiscovery(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthDiscovery
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Apps[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestTimestamp", wireType)
			}
			m.LatestTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDiscovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Instances) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiscovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Instances: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Instances: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instances = append(m.Instances, &Instance{})
			if err := m.Instances[len(m.Instances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDiscovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiscovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Instance == nil {
				m.Instance = make(map[string]*Instances)
			}
			var mapkey string
			var mapvalue *Instances
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDiscovery
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDiscovery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDiscovery
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDiscovery
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDiscovery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthDiscovery
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthDiscovery
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Instances{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDiscovery(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthDiscovery
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Instance[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheduler", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheduler = append(m.Scheduler, &Zone{})
			if err := m.Scheduler[len(m.Scheduler)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestTimestamp", wireType)
			}
			m.LatestTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDiscovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RespFech) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiscovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RespFech: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RespFech: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Code = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &InstanceInfo{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestTimestamp", wireType)
			}
			m.LatestTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestTimestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDiscovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RespFechs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiscovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RespFechs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RespFechs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Code = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = make(map[string]*InstanceInfo)
			}
			var mapkey string
			var mapvalue *InstanceInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDiscovery
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDiscovery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDiscovery
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDiscovery
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDiscovery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthDiscovery
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthDiscovery
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &InstanceInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDiscovery(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthDiscovery
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Data[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestTimestamp", wireType)
			}
			m.LatestTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestTimestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDiscovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RespNodes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiscovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RespNodes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RespNodes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Code = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = make(map[string]*Node)
			}
			var mapkey string
			var mapvalue *Node
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDiscovery
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDiscovery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDiscovery
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDiscovery
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDiscovery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthDiscovery
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthDiscovery
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Node{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDiscovery(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthDiscovery
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Data[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestTimestamp", wireType)
			}
			m.LatestTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestTimestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDiscovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgRegister) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiscovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgRegister: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgRegister: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addrs = append(m.Addrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replication", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Replication = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestTimestamp", wireType)
			}
			m.LatestTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirtyTimestamp", wireType)
			}
			m.DirtyTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DirtyTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDiscovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgRenew) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiscovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgRenew: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgRenew: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replication", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Replication = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirtyTimestamp", wireType)
			}
			m.DirtyTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DirtyTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDiscovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgCancel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiscovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgCancel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgCancel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replication", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Replication = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestTimestamp", wireType)
			}
			m.LatestTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDiscovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgFetch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiscovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgFetch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgFetch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDiscovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgFetchs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiscovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgFetchs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgFetchs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = append(m.AppID, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDiscovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgRoll) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiscovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgRoll: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgRoll: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestTimestamp", wireType)
			}
			m.LatestTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDiscovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArgRolls) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiscovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArgRolls: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArgRolls: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = append(m.AppID, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDiscovery
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LatestTimestamp = append(m.LatestTimestamp, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDiscovery
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDiscovery
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDiscovery
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LatestTimestamp) == 0 {
					m.LatestTimestamp = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDiscovery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LatestTimestamp = append(m.LatestTimestamp, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestTimestamp", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDiscovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArqSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDiscovery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArqSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArqSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = append(m.Hostname, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Status = append(m.Status, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDiscovery
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDiscovery
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDiscovery
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Status) == 0 {
					m.Status = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Status = append(m.Status, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDiscovery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDiscovery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replication", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Replication = bool(v != 0)
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetTimestamp", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.SetTimestamp = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipDiscovery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDiscovery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDiscovery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDiscovery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDiscovery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDiscovery
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthDiscovery
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDiscovery
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDiscovery(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthDiscovery
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDiscovery = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDiscovery   = fmt.Errorf("proto: integer overflow")
)
